<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="使用懒加载和Suspense提高React性能"/><meta name="keywords" content="陈鑫谱,xinpu,昕浦,xinpuchen,前端,frontend-notes,awesome-coding" /><link rel="alternate" href="/atom.xml" title="Xinpu's Blog"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=2.11.0" />
<link rel="canonical" href="https://xinpuchen.github.io/improve-react-performance-using-lazy-loading-and-suspense/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" /><script type="text/x-mathjax-config">
    MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":true};
</script>

    <title>使用懒加载和Suspense提高React性能 - Xinpu's Blog</title>
  <meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Xinpu's Blog" type="application/atom+xml">
</head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Xinpu's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首页
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">归档
          </li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签
          </li>
      </a><a href="https://xinpuchen.top/frontend-notes/" target="_blank" rel="noopener">
        <li class="mobile-menu-item">前端笔记
          </li>
      </a><a href="https://xinpuchen.top/awesome-coding/" target="_blank" rel="noopener">
        <li class="mobile-menu-item">算法练习
          </li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Xinpu's Blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            归档
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/categories/">
            分类
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            标签
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="https://xinpuchen.top/frontend-notes/" target="_blank" rel="noopener">
            前端笔记
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="https://xinpuchen.top/awesome-coding/" target="_blank" rel="noopener">
            算法练习
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about/">
            关于
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">使用懒加载和Suspense提高React性能
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-01-25
        </span><span class="post-category">
            <a href="/categories/React/">React</a>
            </span>
        </div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#什么是-Lazy-Loading💤？"><span class="toc-text">什么是 Lazy Loading💤？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SSR-CSR-和-React"><span class="toc-text">SSR, CSR 和 React</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#⏬Dynamic-Import"><span class="toc-text">⏬Dynamic Import</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#💤React-lazy"><span class="toc-text">💤React.lazy()</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#🚦React-Suspense"><span class="toc-text">🚦React Suspense</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#👮-捕获加载错误"><span class="toc-text">👮 捕获加载错误</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#✂-基于路由（route-based）的代码拆分"><span class="toc-text">✂ 基于路由（route-based）的代码拆分</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#🔪-基于组件（Component-based）的代码拆分"><span class="toc-text">🔪 基于组件（Component-based）的代码拆分</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#🔚-结论"><span class="toc-text">🔚 结论</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#💞Credits"><span class="toc-text">💞Credits</span></a></li></ol>
    </div>
  </div><div class="post-content"><p>Lazy loading💤 已经成为被广泛应用于加载提速的优化技术之一。延迟加载的前景有助于将某些 web app 出现程序性能问题的风险降至最低〽。</p>
<p>在本文中，我们将研究如何使用 Lazy loading💤 来优化 React 应用程序中的加载时间。</p>
<a id="more"></a>

<h1 id="什么是-Lazy-Loading💤？"><a href="#什么是-Lazy-Loading💤？" class="headerlink" title="什么是 Lazy Loading💤？"></a>什么是 Lazy Loading💤？</h1><p>懒加载是一种优化技巧 💫 我们通过延迟对象(图片 🎦, 视频 🎬, 网页 🌎, 音乐 🎶, 文档 📋) 加载直到他们被使用。</p>
<p>当用户打开一个页面，所有的内容将一次性下载下来。大多数内容可能永远也不会发生作用或者被用户看见。所以为什么要浪费宝贵的资源和带宽呢？</p>
<p>为了提高我们网站的响应时间，我们选择延迟加载一些应用程序中的非关键部分。当用户需要访问这些部分的时候，再加载这些资源。</p>
<h1 id="SSR-CSR-和-React"><a href="#SSR-CSR-和-React" class="headerlink" title="SSR, CSR 和 React"></a>SSR, CSR 和 React</h1><p>我们有 SSR(server-side rendered / 服务端呈现)应用程序和 CSR(Client side rendered / 客户端呈现)应用程序。</p>
<p>SSR 是使用.HTML 构建的优秀传统页面，可以选择配合 ASP.NEt 或是 PHP 等来使用。每个连接都有一个不同的.HTML 文件需要加载。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">web-app&#x2F;</span><br><span class="line"> - index.html</span><br><span class="line"> - about.html</span><br><span class="line"> - faq.html</span><br><span class="line"> - careers.html</span><br></pre></td></tr></table></figure>

<p>每个页面都要记载不同的 HTML 文件。</p>
<p>随着 JS 框架的出现，网页被浑河成为一个单独的 js 并一次性加载完成。在浏览器中执行时，浏览器 DOM 生成所请求的页面。</p>
<p>在 React 中，假设我们有这样的应用程序：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; (</span><br><span class="line">  &lt;Switch&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/about"</span> component=&#123;About&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/faq"</span> component=&#123;FAQ&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/careers"</span> component=&#123;Careers&#125; /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ about.js</span></span><br><span class="line"><span class="regexp">class About extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return &lt;div&gt;About page&lt;/</span>div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// faq.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FAQ</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>FAQ page<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// careers.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Careers</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Careers page<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在打包时，webpack 将所有的 js 文件打包成一个<code>index.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">react-app&#x2F;</span><br><span class="line"> dist&#x2F;</span><br><span class="line">  - index.html</span><br><span class="line">  - index.js</span><br></pre></td></tr></table></figure>

<p>所有的文件包括 index.js, about.js, faq.js, careers.js 都捆绑在一个文件中。现在，当我们加载 index.html 文件时，它会沿着负载很重的 index.js 被加载。现在，解析 index.js 和渲染中的所有代码所花费的时间 ⏰ 将是漫长的等待。如果每个文件执行所花费的时间如下：</p>
<ul>
<li>index.js 2ms</li>
<li>about.js 10ms</li>
<li>faq.js 5ms</li>
<li>careers.js 9ms</li>
</ul>
<p>打包后:</p>
<ul>
<li>index.js 26ms</li>
</ul>
<p>所以我们会等待<code>26ms</code>!!但是如果我们可以将 React 中的文件分开并按需加载它们，我们将在<code>2ms</code>内看到程序加载并相应。</p>
<p>因此，我们可以将包拆分成多个小块并在运行时动态加载，而非一次性下载整个代码。</p>
<p>已经有很多技术用于支持将 React apps 做代码拆分了。我们在下一节中有更多的讲解。</p>
<h1 id="⏬Dynamic-Import"><a href="#⏬Dynamic-Import" class="headerlink" title="⏬Dynamic Import"></a>⏬Dynamic Import</h1><p>为了将我们的 JS 应用做代码分割，将引入 import()函数，目前它仍是一个提案，尚未成为 JavaScript 标准的一部分。</p>
<p>此功能可以将我们的应用程序拆分成为块并按需加载它们。</p>
<p>The import()接受一个字符串作为参数。字符串是将要加载的 js 文件的路径。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">"./js_file_to_load.js"</span>);</span><br></pre></td></tr></table></figure>

<p>当 webpack 遇到这种情况时，它就会将文件分别捆绑在不同路径中。</p>
<h1 id="💤React-lazy"><a href="#💤React-lazy" class="headerlink" title="💤React.lazy()"></a>💤React.lazy()</h1><p>React.lazy 是 Reactv16.6 发布时添加到 React 的新特性，它为我们的 React 组件提供了一种简单直接的方法来完成延迟加载和代码分割。</p>
<blockquote>
<p><em>React.lazy 函数允许你将动态导入的组件按常规呈现。 —</em> <a href="http://reactjs.org/docs/code-splitting.html" target="_blank" rel="noopener"><em>React blog</em></a></p>
</blockquote>
<p>React.lazy 可以轻松创建和渲染组件并动态的导入它们。React.lazy 将函数作为参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">React.lazy(cb);</span><br></pre></td></tr></table></figure>

<p>这个回调函数必须使用动态<code>import()</code>语法来加载组件的文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyComponent.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>MyComponent<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> MyComponent = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">"./MyComponent.js"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AppComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;MyComponent /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ or</span></span><br><span class="line"><span class="regexp">function cb() &#123;</span></span><br><span class="line"><span class="regexp">  return import("./</span>MyComponent.js<span class="string">");</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">const MyComponent = React.lazy(cb);</span></span><br><span class="line"><span class="string">function AppComponent() &#123;</span></span><br><span class="line"><span class="string">  return (</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;MyComponent /&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  );</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>React.lazy 的回调函数会通过<code>import()</code>的调用返回一个 Promise 对象。如果模块加载成功则 Promise 对象 resolve，如果由于网络故障，路径解析错误，找不到文件等原因加载模块时出错，则 Promise 对象 reject。</p>
<p>当 webpack 遍历我们的代码进行编译打包的时候，它会在遇到<code>React.lazy()</code>和<code>import()</code>时，创建一个单独的捆绑包。我们的应用程序将如下显示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">react-app</span><br><span class="line"> dist&#x2F;</span><br><span class="line">  - index.html</span><br><span class="line">  - main.b1234.js (contains Appcomponent and bootstrap code)</span><br><span class="line">  - mycomponent.bc4567.js (contains MyComponent)</span><br><span class="line">&#x2F;** index.html **&#x2F;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;main.b1234.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br></pre></td></tr></table></figure>

<p>现在，我们的应用程序分为多个捆绑包。当 AppComponent 被渲染的时候，mycomponent.bc4567.js 文件将被加载并在 DOM 上的显示包含 MyComponent。</p>
<blockquote>
<p>译者注：目前 React.lazy 还不支持服务端使用，目前官方推荐使用<a href="https://github.com/smooth-code/loadable-components" target="_blank" rel="noopener">Loadable Components</a>，它有很棒的<a href="https://github.com/smooth-code/loadable-components/blob/master/packages/server/README.md" target="_blank" rel="noopener">服务端渲染指南</a>。或者你也可以尝试使用<a href="https://github.com/jamiebuilds/react-loadable" target="_blank" rel="noopener">react-loadable</a>，这是一个小型库，用于加载具有动态导入组件的高阶组件，使用它你可以完成错误超时状态配置、避免加载闪烁、加载多个资源、预加载、服务端渲染等功能。</p>
</blockquote>
<h1 id="🚦React-Suspense"><a href="#🚦React-Suspense" class="headerlink" title="🚦React Suspense"></a>🚦React Suspense</h1><p>现在，当文件 mycomponent.bc4567.js 被加载时会发生什么，从加载到 MyComponent 被渲染必定会有一个时间延迟。用户会看到什么呢？</p>
<p>显然，你的应用程序似乎会冻结一段时间。这将是个糟糕的用户体验。我们需要让用户指导正在发生或加载的事情。为了做到这一点，添加了与 React.lazy 相关联的新特性，他就是<code>Suspense</code>组件。</p>
<p>Suspense 组件用于包装延迟组件，以在加载惰性组件时显示一些备用信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Lazycomponent = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./lazy.component.js"</span>));</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AppComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Suspense fallback=&#123;&lt;div&gt;loading ...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &lt;LazyComponent /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正在延迟加载的组件将插入到 Suspense 组件的标记内。向用户展示的内容告诉他们正在进行的内容放在 Suspense 组件标记的 fallback prop 中。</p>
<p>组件也可以用于 fallback prop：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LoadingIndicator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>loading ...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AppComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Suspense fallback=&#123;&lt;LoadingIndicator /&gt;&#125;&gt;</span><br><span class="line">        &lt;LazyComponent /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以再 Suspense 标记中放置多个惰性组件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Lazycomponent1 = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./lazy.component1.js"</span>));</span><br><span class="line"><span class="keyword">const</span> Lazycomponent2 = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./lazy.component2.js"</span>));</span><br><span class="line"><span class="keyword">const</span> Lazycomponent3 = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./lazy.component3.js"</span>));</span><br><span class="line"><span class="keyword">const</span> Lazycomponent4 = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./lazy.component4.js"</span>));</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AppComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;div&gt;loading ...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;LazyComponent1 /</span>&gt;</span><br><span class="line">      &lt;LazyComponent2 /&gt;</span><br><span class="line">      &lt;LazyComponent3 /&gt;</span><br><span class="line">      &lt;LazyComponent4 /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="👮-捕获加载错误"><a href="#👮-捕获加载错误" class="headerlink" title="👮 捕获加载错误"></a>👮 捕获加载错误</h1><p>在我们使用 React.lazy 时，我们提到 import()函数会返回一个 Promise 对象，可能会由于某些原因在 reject 中返回加载错误：</p>
<ul>
<li>网络故障</li>
<li>文件未找到</li>
<li>文件路径错误</li>
</ul>
<p>现在，我们不希望我们的应用程序因为这些悲惨地发生错误。我们希望荣耀的有尊严地错误。为了在失败时展现出良好的用户体验，我们将在惰性组件上放置一个错误边界。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Lazycomponent1 = React.lazy(<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">import</span>(<span class="string">'./lazy.component1.js'</span>))</span><br><span class="line"><span class="keyword">const</span> Lazycomponent2 = React.lazy(<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">import</span>(<span class="string">'./lazy.component2.js'</span>))</span><br><span class="line"><span class="keyword">const</span> Lazycomponent3 = React.lazy(<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">import</span>(<span class="string">'./lazy.component3.js'</span>))</span><br><span class="line"><span class="keyword">const</span> Lazycomponent4 = React.lazy(<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">import</span>(<span class="string">'./lazy.component4.js'</span>))</span><br><span class="line"><span class="keyword">import</span> ErrorBoundary <span class="keyword">from</span> <span class="string">'./error.boundary.js'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AppComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;ErrorBoundary&gt;</span><br><span class="line">            &lt;Suspense fallback=&#123;&lt;div&gt;loading ...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">                &lt;LazyComponent1 /</span>&gt;</span><br><span class="line">                &lt;LazyComponent2 /&gt;</span><br><span class="line">                &lt;LazyComponent3 /&gt;</span><br><span class="line">                &lt;LazyComponent4 /&gt;</span><br><span class="line">            &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ErrorBoundary/</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="✂-基于路由（route-based）的代码拆分"><a href="#✂-基于路由（route-based）的代码拆分" class="headerlink" title="✂ 基于路由（route-based）的代码拆分"></a>✂ 基于路由（route-based）的代码拆分</h1><p>如何拆分代码是个棘手的问题。有两种最常用的方法是基于路由（<code>route-based</code>）拆分和基于组件（<code>component-based</code>）拆分。</p>
<blockquote>
<p><em>基于路由的代码拆分将应用程序分解为每个路由对应的块。</em></p>
</blockquote>
<p>基于路由的代码拆分是将代码拆分为与应用程序路由相关的包。在 SPA（single page web application，单页面应用）中，所有的 route 或 path 都是在 DOM 上完成的。当你点击超链接时，DOM 捕获事件并通过 SPA 框架运行它，在 DOM 中将销毁当前视图当组件附加请求路径创建并呈现的时候。</p>
<p>所有的这些组件都捆绑在一个文件中被传递。现在，通过基于路由的分块，我们可以将代码分成块。每个块只与特定路由有关。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index,js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;Switch&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/about"</span> component=&#123;About&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/faq"</span> component=&#123;FAQ&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/careers"</span> component=&#123;Careers&#125; /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>

<p>当我们使用基于路由的方法拆分次应用程序时，我们将看到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">react-app&#x2F;</span><br><span class="line"> - index.html</span><br><span class="line"> - index.bacd0123.js (contains App)</span><br><span class="line"> - about.1234.js (contains About component)</span><br><span class="line"> - faq.5678.js (contains FAQ component)</span><br><span class="line"> - careers.9012.js (contains Careers component)</span><br><span class="line">&#x2F;** index.html **&#x2F;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;index.bacd0123.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br></pre></td></tr></table></figure>

<p>当我们加载我们的 app 路径<code>/</code>时，应用仅呈现该页面。现在，如果我们导航到<code>/faq</code>，那么 faq.5678.js 文件将通过网络获取并加载，包括组件 FAQ 将被渲染。</p>
<p>因此，我们将看到的代码是根据我们定义的路由进行拆分的。这并没有 100%优化我们的应用程序，有一些缺点，但至少我们从我们的应用程序中减少了相当大的延迟时间。这个与代码分割相关的另一种优化技术被称为 prefetching，但这将在另一篇文章中。</p>
<h1 id="🔪-基于组件（Component-based）的代码拆分"><a href="#🔪-基于组件（Component-based）的代码拆分" class="headerlink" title="🔪 基于组件（Component-based）的代码拆分"></a>🔪 基于组件（Component-based）的代码拆分</h1><p>在 Web 应用程序中，有如下许多小部件：</p>
<ul>
<li>模型（modals）</li>
<li>tabs</li>
<li>折叠面板（accordion）</li>
<li>进度条（progressbars）</li>
<li>侧边菜单（sidenav）</li>
<li>footer</li>
<li>header</li>
<li>面板（panel）</li>
<li>等等</li>
</ul>
<p>这些小部件或组件为我们的用户提供了丰富的体验。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ModalComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">modal</span>&gt;</span>Modal shows!!!<span class="tag">&lt;/<span class="name">modal</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mycomponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.display = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;ModalComponent display=&#123;<span class="keyword">this</span>.dispaly&#125; /&gt;</span><br><span class="line">    &lt;button onclick=&#123;(<span class="keyword">this</span>.display = <span class="literal">true</span>)&#125;&gt;Open Modal&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button onclick=&#123;(this.display = false)&#125;&gt;Close Modal&lt;/</span>button&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">react - app /</span> dist / -index.html - index.js;</span><br></pre></td></tr></table></figure>

<p>尽管他们提供了很多好东西，但他们也会导致我们的应用程序性能不佳。大多数组件隐藏，指导用户完成相关操作时才会显现。在用户滚动到底部或按侧边按钮之前，你不会看到 footer 和 sidenev。大多数情况下，用户甚至可能不会与其中任意一个进行交互。</p>
<p>所有这些都加载到我们的应用程序中，并在加载时构成时间延迟。当用户试图与他们交互时，加载并展现他们不会更好么？</p>
<p>在这种情况下，基于组件的拆分有很大的帮助。所有的小部件或组件都将单独打包。每个捆绑包上一个小部件，Web 开发人员需要采用捆绑技术，但更重要的是按需加载这些部件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// modalcomponent.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ModalComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">modal</span>&gt;</span>Modal shows!!!<span class="tag">&lt;/<span class="name">modal</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mycomponent.js</span></span><br><span class="line"><span class="keyword">const</span> ModalComponent = React.lazy(<span class="keyword">import</span>(<span class="string">'./modalcomponent.js'</span>))</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.display = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;Suspense fallback=&#123;&lt;div&gt;loading ...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">            &lt;ModalComponent display=&#123;this.display&#125; /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onclick=&#123;this.display = true&#125;&gt;Open Modal&lt;/</span>button&gt;</span><br><span class="line">        &lt;button onclick=&#123;<span class="keyword">this</span>.display = <span class="literal">false</span>&#125;&gt;Close Modal&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> MyComponent = React.lazy(<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">import</span>(<span class="string">'./mycomponent.js'</span>))</span><br><span class="line"><span class="keyword">import</span> ErrorBoundary <span class="keyword">from</span> <span class="string">'./error.boundary.js'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AppComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;ErrorBoundary&gt;</span><br><span class="line">            &lt;Suspense fallback=&#123;&lt;div&gt;loading ...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">                &lt;MyComponent /</span>&gt;</span><br><span class="line">            &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ErrorBoundary/</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">react-app/</span></span><br><span class="line"> dist/</span><br><span class="line">  - index.html</span><br><span class="line">  - index.js</span><br><span class="line">  - mycomponent.js</span><br><span class="line">  - modalcomponent.js (contains the ModalComponent)</span><br></pre></td></tr></table></figure>

<p>我们看到最初没有加载 ModalComponent，他在用户单击<code>Open Modal</code>按钮时，才会触发加载。</p>
<h1 id="🔚-结论"><a href="#🔚-结论" class="headerlink" title="🔚 结论"></a>🔚 结论</h1><p>在这篇文章中，我们看到了如何通过代码分割和延迟加载来改进 🚀React 应用程序的性能。首先我们介绍了动态 import()函数；然后，我们看到了还可以使用不同的技术方案，如 React 的新特性 💤<code>React.lazy()</code>和 🚦<code>Suspense</code>。</p>
<p>通过我们在这篇文章中学到的这些不同的优化技巧，我们可以生成高性能高质量的 React 应用。</p>
<p>如果你对此有任何问题，或者我有任何遗漏，请随时在下面发表评论或向我询问任何问题！👏 你也可以在<a href="https://twitter.con/@ngarchangel" target="_blank" rel="noopener">Twitter</a>, <a href="https://facebook.com/philip.david.5011" target="_blank" rel="noopener">Facebook</a>和这里找到我。</p>
<p>蟹蟹 !!!💯</p>
<h1 id="💞Credits"><a href="#💞Credits" class="headerlink" title="💞Credits"></a>💞Credits</h1><ul>
<li><a href="https://gist.github.com/philipszdavido/reactjs.org/docs/code-splitting.html" target="_blank" rel="noopener">✅Reactjs Blog</a></li>
</ul>
<p>原文链接： <a href="https://blog.bitsrc.io/improve-react-performance-using-lazy-loading-and-suspense-933903171954" target="_blank" rel="noopener">Improve React Performance using Lazy Loading💤 and Suspense</a></p>
<p><a href="https://zakarycode.github.io/archives/front-end/frame/React/1546835543.html" target="_blank" rel="noopener">转载链接</a></p>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="https://xinpuchen.github.io">昕浦</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="https://xinpuchen.github.io/improve-react-performance-using-lazy-loading-and-suspense/">https://xinpuchen.github.io/improve-react-performance-using-lazy-loading-and-suspense/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/JavaScript/">JavaScript</a>
            <a href="/tags/React/">React</a>
            <a href="/tags/Performance/">Performance</a>
            <a href="/tags/Web-Development/">Web Development</a>
            <a href="/tags/Programming/">Programming</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/Why-Isn%E2%80%99t-X-a-Hook/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">为什么选择Hook而非……?</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    <a class="next" href="/React-16.6.*/">
        <span class="next-text nav-default">React 16.6 发布，一大波新功带你看未来的 React 开发方式</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"><div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:xinpuchen@foxmail.com" class="iconfont icon-email" title="email"></a>
        <a href="https://www.linkedin.com/in/xinpuchen" target="_blank" rel="noopener" class="iconfont icon-linkedin" title="linkedin"></a>
        <a href="https://github.com/xinpuchen" target="_blank" rel="noopener" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a>
  </span>

  <span class="copyright-year">&copy;2018 - 2020<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">昕浦</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'https://xinpuchen.github.io/improve-react-performance-using-lazy-loading-and-suspense/';
        this.page.identifier = 'improve-react-performance-using-lazy-loading-and-suspense/';
        this.page.title = '使用懒加载和Suspense提高React性能';
    };
    (function() {
    var d = document, s = d.createElement('script');

    s.src = '//xinpuchen.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();  
  </script>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"/>


<script src="//cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js"></script>

<script>
  var gitalk = new Gitalk({
    clientID: 'GitHub Application Client ID',
    clientSecret: 'GitHub Application Client Secret',
    repo: 'GitHub repo',
    owner: 'GitHub repo owner',
    admin: ['GitHub repo owner and collaborators, only these guys can initialize github issues'],
    id: md5(location.pathname),
    
      language: 'zh-CN',
    
    distractionFreeMode: 'true'
  });
  gitalk.render('gitalk-container');
</script><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
