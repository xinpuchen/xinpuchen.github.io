<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="JavaScript 预解释是一种毫无节操的机制"/><meta name="keywords" content="陈鑫谱,xinpu,昕浦,xinpuchen,前端,frontend-notes,awesome-coding" /><link rel="alternate" href="/atom.xml" title="Xinpu's Blog"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=2.11.0" />
<link rel="canonical" href="https://xinpuchen.github.io/pre-interpretation/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" /><script type="text/x-mathjax-config">
    MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":true};
</script>

    <title>JavaScript 预解释是一种毫无节操的机制 - Xinpu's Blog</title>
  <meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Xinpu's Blog" type="application/atom+xml">
</head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Xinpu's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首页
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">归档
          </li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签
          </li>
      </a><a href="https://xinpuchen.top/frontend-notes/" target="_blank" rel="noopener">
        <li class="mobile-menu-item">前端笔记
          </li>
      </a><a href="https://xinpuchen.top/awesome-coding/" target="_blank" rel="noopener">
        <li class="mobile-menu-item">算法练习
          </li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Xinpu's Blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            归档
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/categories/">
            分类
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            标签
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="https://xinpuchen.top/frontend-notes/" target="_blank" rel="noopener">
            前端笔记
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="https://xinpuchen.top/awesome-coding/" target="_blank" rel="noopener">
            算法练习
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about/">
            关于
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">JavaScript 预解释是一种毫无节操的机制
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-01-14
        </span><span class="post-category">
            <a href="/categories/JavaScript/">JavaScript</a>
            </span>
        </div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是预解释"><span class="toc-text">什么是预解释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#理解声明和定义"><span class="toc-text">理解声明和定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对于带-var-和-function-关键字的在预解释的时候操作不一样的"><span class="toc-text">对于带 var 和 function 关键字的在预解释的时候操作不一样的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#预解释只发生在当前的作用域下。"><span class="toc-text">预解释只发生在当前的作用域下。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#作用域链与闭包"><span class="toc-text">作用域链与闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何区分私有变量和全局变量？"><span class="toc-text">如何区分私有变量和全局变量？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包"><span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS-中内存的分类"><span class="toc-text">JS 中内存的分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#var-num-12-与-num-12-有啥区别？"><span class="toc-text">var num&#x3D;12 与 num&#x3D;12 有啥区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#预解释五大毫无节操的表现"><span class="toc-text">预解释五大毫无节操的表现</span></a></li></ol>
    </div>
  </div><div class="post-content"><p><img src="/images/pre-interpretation-1.png" alt=""></p>
<h2 id="什么是预解释"><a href="#什么是预解释" class="headerlink" title="什么是预解释"></a>什么是预解释</h2><p>js 代码执行之前，浏览器首先会默认的把所有带 var 和 function 的进行提前的声明或者定义</p>
<a id="more"></a>

<h3 id="理解声明和定义"><a href="#理解声明和定义" class="headerlink" title="理解声明和定义"></a>理解声明和定义</h3><p>声明(declare):如 var num;=&gt;告诉浏览器在全局作用域中有一个 num 的变量了；如果一个变量只是声明了但是没有赋值，默认的值是 undefined</p>
<p>定义(defined):如 num=12;=&gt;给我们的变量进行赋值。</p>
<h3 id="对于带-var-和-function-关键字的在预解释的时候操作不一样的"><a href="#对于带-var-和-function-关键字的在预解释的时候操作不一样的" class="headerlink" title="对于带 var 和 function 关键字的在预解释的时候操作不一样的"></a>对于带 var 和 function 关键字的在预解释的时候操作不一样的</h3><p>var =&gt;在预解释的时候只是提前的声明</p>
<p>function =&gt;在预解释的时候提前的声明+定义都完成了</p>
<h3 id="预解释只发生在当前的作用域下。"><a href="#预解释只发生在当前的作用域下。" class="headerlink" title="预解释只发生在当前的作用域下。"></a>预解释只发生在当前的作用域下。</h3><p>例如：开始只对 window 下的进行预解释，只有函数执行的时候才会对函数中的进行预解释</p>
<h2 id="作用域链与闭包"><a href="#作用域链与闭包" class="headerlink" title="作用域链与闭包"></a>作用域链与闭包</h2><h3 id="如何区分私有变量和全局变量？"><a href="#如何区分私有变量和全局变量？" class="headerlink" title="如何区分私有变量和全局变量？"></a>如何区分私有变量和全局变量？</h3><ul>
<li><strong>在全局作用域下声明（预解释的时候）的变量是全局变量</strong></li>
<li><strong>只有函数执行会产生私有的作用域,比如 for(){}、if(){}和 switch(){}都不会产生私有作用域</strong></li>
<li><strong>在”私有作用域中声明的变量(var 声明)”和”函数的形参”都是私有的变量</strong>。在私有作用域中，代码执行的时保遇到了一个变量，首先我们需要确定它是否为私有的变量，如果是私有的变量，那么和外面的没有在何的关系；如果不是私有的，则往当前作用域的上级作用域进行查找，如果上级作用域也没有则继续查找，一直找到 window 为止，这就是作用域链。</li>
</ul>
<p>我们举个例子来区别私有变量和全局变量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//=&gt;变量提升：var a；var b；var c；test=AAAFFF111；</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="number">10</span>,b=<span class="number">11</span>,c=<span class="number">12</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//=&gt;私有作用域：a=10 var b；</span></span><br><span class="line">  a=<span class="number">1</span>;<span class="comment">//=&gt;私有变量a=1</span></span><br><span class="line">  <span class="keyword">var</span> b=<span class="number">2</span>；<span class="comment">//=&gt;私有变量b=2</span></span><br><span class="line">  c=<span class="number">3</span>;<span class="comment">//=&gt;全局变量c=3</span></span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">10</span>）；</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(b):<span class="comment">//11</span></span><br><span class="line"><span class="built_in">console</span>.log(c);<span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p><strong>判断是否是私有变量一个标准就是是否是在函数中 var 声明的变量和函数的形参都是私有的变量</strong>。本道题目在 test 函数中 a 是形参和 var b 定义的变量 b 都是私有变量。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><strong>闭包是一种机制，函数执行时形成一个新的私有的作用域保护了里面的私有变量不受外界的干扰（外面修改不了私有的，私有的也修改不了外面的）</strong></p>
<ul>
<li>这是因为当函数执行的时候,首先会形成一个新的私有的作用域，然后按照如下的步骤执行：如果有形参，先给形参赋值</li>
<li>进行私有作用域中的预解释</li>
<li>私有作用域中的代码从上到下执行</li>
</ul>
<p>我们来看一道例题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> total=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(total);<span class="comment">//-&gt;undefined 外面修改不了私有的</span></span><br><span class="line">  <span class="keyword">var</span> total=num1 +num2；</span><br><span class="line">  <span class="built_in">console</span>.log(total);<span class="comment">//-&gt;300</span></span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line"><span class="built_in">console</span>.log(total);<span class="comment">//-&gt;0 私有的也修改不了外面的</span></span><br></pre></td></tr></table></figure>

<h3 id="JS-中内存的分类"><a href="#JS-中内存的分类" class="headerlink" title="JS 中内存的分类"></a>JS 中内存的分类</h3><p>栈内存：用来提供一个供 JS 代码执行的环境，即作用域（全局作用域/私有的作用域）<br>堆内存：用来存储引用数据类型的值。对象存储的是属性名和属性值，函数存储的是代码字符串。</p>
<h2 id="var-num-12-与-num-12-有啥区别？"><a href="#var-num-12-与-num-12-有啥区别？" class="headerlink" title="var num=12 与 num=12 有啥区别？"></a>var num=12 与 num=12 有啥区别？</h2><p>我们先来看以下两个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例题1</span></span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">//-&gt;undefined</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">12</span>;</span><br><span class="line"><span class="comment">//例题2</span></span><br><span class="line"><span class="built_in">console</span>.log(num2); <span class="comment">//-&gt;Uncaught ReferenceError:num2 is not defined</span></span><br><span class="line">num2 = <span class="number">12</span>; <span class="comment">//不能预解释</span></span><br></pre></td></tr></table></figure>

<p>当你看到 var num=12 时，可能会认为这是个声明。但<strong>JavaScript 实际上会将其看成两个声明：var num;和 num=12;第一个定义声明是在预解释阶段进行的。第二个赋值声明会被留在原地等待执行阶段。</strong></p>
<p><strong>最大区别：带 var 的可以进行预解释，所以在赋值的前面执行不会报错；不带 var 的是不能进行预解释的，在前面执行会报错；</strong></p>
<p>除此之外，num2=12; 相当于给 window 增加了一个叫做 num2 的属性名，属性值是 12,而 var num=12; 首先它相当于给全局作用域增加了一个全局变量 num，它也相当于给 window 增加了一个属性名 num，属性值是 12。</p>
<p>接下来我们举例说明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例题1</span></span><br><span class="line"><span class="keyword">var</span> total=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(total);<span class="comment">//undefined</span></span><br><span class="line">  <span class="keyword">var</span> total=<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line"><span class="built_in">console</span>.log(total);<span class="comment">//0</span></span><br><span class="line"><span class="comment">//例题2</span></span><br><span class="line"><span class="keyword">var</span> total=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(total);<span class="comment">//0</span></span><br><span class="line">  total=<span class="number">100</span>；</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line"><span class="built_in">console</span>.log(total);<span class="comment">//100</span></span><br></pre></td></tr></table></figure>

<p>例题 1 中带 var 变量在私有作用域中可以预解释，所以第一个 console 打出来的值为 undefined。<strong>私有作用域中出现的一个变量不是私有的，则往上级作用域进行查找，上级没有则继续向上查找，一直找到 window 为止</strong>，例题 2 中不带 var 变量不是私有的，所以往上级找</p>
<h2 id="预解释五大毫无节操的表现"><a href="#预解释五大毫无节操的表现" class="headerlink" title="预解释五大毫无节操的表现"></a>预解释五大毫无节操的表现</h2><p><strong>1、预解释的时候不管你的条件是否成立，都要把带 var 的进行提前的声明。</strong></p>
<p>请看下面这道例题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>（!(<span class="string">"num"</span> <span class="keyword">in</span>  <span class="built_in">window</span>))&#123;</span><br><span class="line">  <span class="keyword">var</span> num=<span class="number">12</span>；<span class="comment">//这句话会被提到大括号之外的全局作用域：var num;-&gt;window.num；</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>2、预解释的时候只预解释”=”左边的，右边的值，不参与预解释</strong></p>
<p>请看下面这道例题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn(); <span class="comment">//报错</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//window下的预解释：var fn；</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"ok"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>3、自执行函数：定义和执行一起完成了。</strong></p>
<p>自执行函数定义的那个 function 在全局作用域下不进行预解释，当代码执行到这个位置的时候定义和执行一起完成了。常见有以下几种形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;&#125;)(<span class="number">10</span>);</span><br><span class="line">~<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;&#125;(<span class="number">10</span>);</span><br><span class="line">+<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;&#125;(<span class="number">10</span>);</span><br><span class="line">-<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;&#125;(<span class="number">10</span>);</span><br><span class="line">！<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;&#125;(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p><strong>4、函数体中 return 下面的代码虽然不再执行了，但是需要进行预解释；return 后面跟着的都是我们返回的值，所以不进行预解释；</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//预解释：var num；</span></span><br><span class="line">  <span class="built_in">console</span>.log(num）;<span class="comment">//-&gt;undefined</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> num=<span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p><strong>5、函数声明和变量声明都会被提升。但是一个值得注意的细节（这个细节可以出现在有多个“重复”声明的代码中）是函数会首先被提升，然后才是变量。在预解释的时候，如果名字已经声明过了，不需要从新的声明，但是需要重新的赋值；</strong></p>
<p>我们先来看下两个简单的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例题1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">//'function'</span></span><br><span class="line"><span class="comment">//例题2</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(c);</span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">c(<span class="number">2</span>); <span class="comment">//Uncaught TypeError: c is not a function</span></span><br></pre></td></tr></table></figure>

<p>当遇到存在函数声明和变量声明都会被提升的情况，函数声明优先级比较高，最后变量声明会被函数声明所覆盖，但是可以重新赋值,所以上个例子可以等价为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(c);</span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">c = <span class="number">1</span>;</span><br><span class="line">c(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>接下来我们看下两道比较复杂的题目:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例题3</span></span><br><span class="line">fn();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line"><span class="keyword">var</span> fn = <span class="number">10</span>;</span><br><span class="line">fn();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>一开始预解释，函数声明和赋值一起来，fn 就是 function fn(){console.log(1);}；遇到 var fn=10;不会重新再声明，但是遇到 function fn(){console.log(2);}就会从重新赋值，所以一开始 fn()的值就是 2</li>
</ul>
</blockquote>
<ul>
<li>再执行 fn();值不变还是 2</li>
<li>fn 重新赋值为 10，所以运行 fn()时报错，接下去的语句就没再执行。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例题4</span></span><br><span class="line">alert(a);</span><br><span class="line">a();</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">alert(a);</span><br><span class="line">a = <span class="number">6</span>;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>函数声明优先于变量声明，预解释时候，函数声明和赋值一起来，a 就是 function a(){alert(10)} ，后面遇到 var a=3，也无需再重复声明，所以先弹出 function a(){alert(10)}</li>
</ul>
</blockquote>
<ul>
<li>a()，执行函数，然后弹出 10</li>
<li>接着执行了 var a=3; 所以 alert(a)就是显示 3</li>
<li>由于 a 不是一个函数了，所以往下在执行到 a()的时候， 报错。</li>
</ul>
<p><a href="https://github.com/ljianshu/Blog/issues/3" target="_blank" rel="noopener">原文链接</a></p>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="https://xinpuchen.github.io">Xinpu</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="https://xinpuchen.github.io/pre-interpretation/">https://xinpuchen.github.io/pre-interpretation/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/JavaScript/">JavaScript</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/React-16.6.*/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">React 16.6 发布，一大波新功带你看未来的 React 开发方式</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    <a class="next" href="/js-type-check/">
        <span class="next-text nav-default">JavaScript 数据类型及检测</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"><div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:xinpuchen@foxmail.com" class="iconfont icon-email" title="email"></a>
        <a href="https://www.linkedin.com/in/xinpuchen" target="_blank" rel="noopener" class="iconfont icon-linkedin" title="linkedin"></a>
        <a href="https://github.com/xinpuchen" target="_blank" rel="noopener" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a>
  </span>

  <span class="copyright-year">&copy;2018 - 2020<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Xinpu</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'https://xinpuchen.github.io/pre-interpretation/';
        this.page.identifier = 'pre-interpretation/';
        this.page.title = 'JavaScript 预解释是一种毫无节操的机制';
    };
    (function() {
    var d = document, s = d.createElement('script');

    s.src = '//xinpuchen.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();  
  </script>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"/>


<script src="//cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js"></script>

<script>
  var gitalk = new Gitalk({
    clientID: 'GitHub Application Client ID',
    clientSecret: 'GitHub Application Client Secret',
    repo: 'GitHub repo',
    owner: 'GitHub repo owner',
    admin: ['GitHub repo owner and collaborators, only these guys can initialize github issues'],
    id: md5(location.pathname),
    
      language: 'zh-CN',
    
    distractionFreeMode: 'true'
  });
  gitalk.render('gitalk-container');
</script><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
