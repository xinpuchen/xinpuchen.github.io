<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浏览器缓存机制</title>
      <link href="/browser-caching-mechanism/"/>
      <url>/browser-caching-mechanism/</url>
      
        <content type="html"><![CDATA[<p>Web 缓存是指一个 web 资源（如 html 页面，图片，js，数据等）存在于 web 服务器和客户端（浏览器）之间的副本。</p><p>缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的 URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个 URL 地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。</p><a id="more"></a><h2 id="Web-缓存的作用与类型"><a href="#Web-缓存的作用与类型" class="headerlink" title="Web 缓存的作用与类型"></a>Web 缓存的作用与类型</h2><h3 id="Web-缓存的作用"><a href="#Web-缓存的作用" class="headerlink" title="Web 缓存的作用"></a>Web 缓存的作用</h3><h4 id="减少网络带宽消耗"><a href="#减少网络带宽消耗" class="headerlink" title="减少网络带宽消耗"></a>减少网络带宽消耗</h4><p>无论对于网站运营者或者用户，带宽都代表着金钱，过多的带宽消耗，只会便宜了网络运营商。当 Web 缓存副本被使用时，只会产生极小的网络流量，可以有效的降低运营成本。</p><h4 id="降低服务器压力"><a href="#降低服务器压力" class="headerlink" title="降低服务器压力"></a>降低服务器压力</h4><p>给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，间接降低服务器的压力。同时，搜索引擎的爬虫机器人也能根据过期机制降低爬取的频率，也能有效降低服务器的压力。</p><h4 id="减少网络延迟，加快页面打开速度"><a href="#减少网络延迟，加快页面打开速度" class="headerlink" title="减少网络延迟，加快页面打开速度"></a>减少网络延迟，加快页面打开速度</h4><p>带宽对于个人网站运营者来说是十分重要，而对于大型的互联网公司来说，可能有时因为钱多而真的不在乎。那 Web 缓存还有作用吗？答案是肯定的，对于最终用户，缓存的使用能够明显加快页面打开速度，达到更好的体验。</p><h3 id="Web-缓存的类型"><a href="#Web-缓存的类型" class="headerlink" title="Web 缓存的类型"></a>Web 缓存的类型</h3><ul><li>数据库数据缓存</li><li>服务器端缓存</li><li>浏览器端缓存</li><li>web 应用层缓存</li></ul><h2 id="Web-缓存的工作原理"><a href="#Web-缓存的工作原理" class="headerlink" title="Web 缓存的工作原理"></a>Web 缓存的工作原理</h2><p>所有的缓存都是基于一套规则来帮助他们决定什么时候使用缓存中的副本提供服务。这些规则有的在协议中有定义（如 HTTP 协议 1.0 和 1.1），有的则是由缓存的管理员设置（如 DBA、浏览器的用户、代理服务器管理员或者应用开发者）。</p><h3 id="浏览器端的缓存规则"><a href="#浏览器端的缓存规则" class="headerlink" title="浏览器端的缓存规则"></a>浏览器端的缓存规则</h3><p>对于浏览器端的缓存来讲，这些规则是在 HTTP 协议头和 HTML 页面的 Meta 标签中定义的。他们分别从<strong>新鲜度</strong>和<strong>校验值</strong>两个维度来规定浏览器是直接使用缓存中的副本，还是需要去源服务器获取更新的版本。</p><h4 id="新鲜度-过期机制"><a href="#新鲜度-过期机制" class="headerlink" title="新鲜度(过期机制)"></a>新鲜度(过期机制)</h4><p>也就是缓存副本有效期。一个缓存副本必须满足以下任一条件，浏览器会认为它是有效的，足够新的，而直接从缓存中获取副本并渲染：</p><ul><li>含有完整的过期时间控制头信息（HTTP 协议报头），并且仍在有效期内</li><li>浏览器已经使用过这个缓存副本，并且在一个会话中已经检查过新鲜度</li></ul><h4 id="校验值-验证机制"><a href="#校验值-验证机制" class="headerlink" title="校验值(验证机制)"></a>校验值(验证机制)</h4><p>服务器返回资源的时候有时在控制头信息带上这个资源的实体标签 Etag（Entity Tag），它可以用来作为浏览器再次请求过程的校验标识。如果发现校验标识不匹配，说明资源已经被修改或过期，浏览器需求重新获取资源内容。</p><h3 id="浏览器缓存的控制"><a href="#浏览器缓存的控制" class="headerlink" title="浏览器缓存的控制"></a>浏览器缓存的控制</h3><h4 id="使用-HTML-的-meta-标签"><a href="#使用-HTML-的-meta-标签" class="headerlink" title="使用 HTML 的 meta 标签"></a>使用 HTML 的 meta 标签</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Pragma"</span> <span class="attr">content</span>=<span class="string">"no-cache"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码的作用是告诉浏览器当前页面不被缓存，每次访问都需要去服务器拉取。使用上很简单，但只有部分浏览器可以支持，而且所有缓存代理服务器都不支持，因为代理不解析 HTML 内容本身。</p><h4 id="使用缓存有关的-HTTP-消息报头"><a href="#使用缓存有关的-HTTP-消息报头" class="headerlink" title="使用缓存有关的 HTTP 消息报头"></a>使用缓存有关的 HTTP 消息报头</h4><p>一个 URI 的完整 HTTP 协议交互过程是由 HTTP 请求和 HTTP 响应组成的。</p><p><img src="/images/http-cache-relevant.png" alt=""></p><h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><ul><li>max-age：（单位为 s）指定设置缓存最大的有效时间，定义的是时间长短。当浏览器向服务器发送请求后，在 max-age 这段时间里浏览器就不会再向服务器发送请求了。我们来找个资源看下。比如 QQ 推广上的 css 资源，max-age=3600，也就是说缓存有效期为 3600 秒（也就是 1h）。于是在 1 天内都会使用这个版本的资源，即使服务器上的资源发生了变化，浏览器也不会得到通知。max-age 会覆盖掉 Expires，后面会有讨论。</li><li>s-maxage：（单位为 s）同 max-age，只用于共享缓存（如 CDN 缓存）。比如，当 s-maxage=60 时，在这 60 秒中，即使更新了 CDN 的内容，浏览器也不会进行请求。也就是说 max-age 用于普通缓存，而 s-maxage 用于代理缓存。如果存在 s-maxage，则会覆盖掉 max-age 和 Expires header。</li><li>public：指定响应会被缓存，并且在多用户间共享。也就是下图的意思。如果没有指定 public 还是 private，则默认为 public。</li><li>private：响应只作为私有的缓存（见下图），不能在用户间共享。如果要求 HTTP 认证，响应会自动设置为 private。</li><li>no-cache：指定不缓存响应，表明资源不进行缓存，但是设置了 no-cache 之后并不代表浏览器不缓存，而是在获取缓存前要向服务器确认资源是否被更改。因此有的时候只设置 no-cache 防止缓存还是不够保险，还可以加上 private 指令，将过期时间设为过去的时间。</li><li>no-store：绝对禁止缓存，一看就知道如果用了这个命令当然就是不会进行缓存啦～每次请求资源都要从服务器重新获取。</li><li>must-revalidate：指定如果页面是过期的，则去服务器进行获取。这个指令并不常用，就不做过多的讨论了。</li></ul><p><img src="/images/cache-control.png" alt=""></p><h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h5><p>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说， Expires=max-age + 请求时间 ，需要和 Last-modified 结合使用。但在上面我们提到过，cache-control 的优先级更高。Expires 是 Web 服务器响应消息头字段，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p><h5 id="Last-modified-amp-If-modified-since"><a href="#Last-modified-amp-If-modified-since" class="headerlink" title="Last-modified &amp; If-modified-since"></a>Last-modified &amp; If-modified-since</h5><p>服务器端文件的最后修改时间，需要和 cache-control 共同使用，是检查服务器端资源是否更新的一种方式。当浏览器再次进行请求时，会向服务器传送 If-Modified-Since 报头，询问 Last-Modified 时间点之后资源是否被修改过。如果没有修改，则返回码为 304，使用缓存；如果修改过，则再次去服务器请求资源，返回码和首次请求相同为 200，资源为服务器最新资源。</p><h5 id="Etag-amp-If-None-Match"><a href="#Etag-amp-If-None-Match" class="headerlink" title="Etag &amp; If-None-Match"></a>Etag &amp; If-None-Match</h5><p>根据实体内容生成一段 hash 字符串，标识资源的状态，由服务端产生。浏览器会将这串字符串传回服务器，验证资源是否已经修改，如果没有修改，过程如下：</p><p><img src="/images/expires-etag.png" alt=""></p><h5 id="缓存报头种类和优先级"><a href="#缓存报头种类和优先级" class="headerlink" title="缓存报头种类和优先级"></a>缓存报头种类和优先级</h5><ul><li><p>Cache-Control 与 Expires</p><p>Cache-Control 与 Expires 的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过 Cache-Control 的选择更多，设置更细致，如果同时设置的话，其优先级高于 Expires。</p></li><li><p>Last-Modified 与 ETag</p><p>你可能会觉得使用 Last-Modified 已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要 Etag（实体标识）呢？HTTP1.1 中 Etag 的出现主要是为了解决几个 Last-Modified 比较难解决的问题：</p><ul><li>Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在 1 秒钟以内，被修改多次的话，它将不能准确标注文件的新鲜度。</li><li>如果某些文件会被定期生成，当有时内容并没有任何变化，但 Last-Modified 却改变了，导致文件没法使用缓存。</li><li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形。</li></ul><p>Etag 是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。Etag 的服务器生成规则和强弱 Etag 的相关内容可以参考，《互动百科-Etag》和《HTTP Header definition》，这里不再深入。</p></li><li><p>Last-Modified/ETag &amp; Cache-Control/Expires</p></li></ul><p>配置 Last-Modified/ETag 的情况下，浏览器再次访问统一 URI 的资源，还是会发送请求到服务器询问文件是否已经修改，如果没有，服务器会只发送一个 304 回给浏览器，告诉浏览器直接从自己本地的缓存取数据；如果修改过那就整个数据重新发给浏览器；</p><p>Cache-Control/Expires 则不同，如果检测到本地的缓存还是有效的时间范围内，浏览器直接使用本地副本，不会发送任何请求。两者一起使用时， Cache-Control/Expires 的优先级要高，即当本地副本根据 Cache-Control/Expires 发现还在有效期内时，则不会再次发送请求去服务器询问修改时间 Last-Modified 或实体标识 Etag 了。</p><p>一般情况下，两者会配合一起使用，因为即使服务器设置缓存时间, 当用户点击“刷新”按钮时，浏览器会忽略缓存继续向服务器发送请求，这时 Last-Modified/ETag 将能够很好利用 304，从而减少响应开销。</p><h5 id="哪些请求不能被缓存？"><a href="#哪些请求不能被缓存？" class="headerlink" title="哪些请求不能被缓存？"></a>哪些请求不能被缓存？</h5><ul><li>HTTP 信息头中包含 Cache-Control:no-cache，pragma:no-cache，或 Cache-Control:max-age=0 等告诉浏览器不用缓存的请求。</li><li>需要根据 Cookie，认证信息等决定输入内容的动态请求是不能被缓存的。</li><li>经过 HTTPS 安全加密的请求（有人也经过测试发现，ie 其实在头部加入 Cache-Control：max-age 信息，firefox 在头部加入 Cache-Control:Public 之后，能够对 HTTPS 的资源进行缓存，参考《HTTPS 的七个误解》)。</li><li>POST 请求无法被缓存。</li><li>HTTP 响应头中不包含 Last-Modified/Etag，也不包含 Cache-Control/Expires 的请求无法被缓存。</li></ul><h4 id="使用缓存流程"><a href="#使用缓存流程" class="headerlink" title="使用缓存流程"></a>使用缓存流程</h4><p>一个用户发起一个静态资源请求的时候，浏览器会通过以下几步来获取并展示资源：</p><p><img src="/images/user-request-process.png" alt=""></p><p>缓存行为主要由缓存策略决定，而缓存策略由内容拥有者设置。这些策略主要通过特定的 HTTP 头部来清晰地表达。</p><p>以上过程也可以被概括为三个阶段：</p><ul><li><strong>本地缓存阶段</strong>：先在本地查找该资源，如果有发现该资源，而且该资源还没有过期，就使用这个资源，完全不会发送 http 请求到服务器；</li><li><strong>协商缓存阶段</strong>：如果在本地缓存找到对应的资源，但是不知道该资源是否过期或者已经过期，则发一个 http 请求到服务器，然后服务器判断这个请求，如果请求的资源在服务器上没有改动过，则返回 304，让浏览器使用本地找到的那个资源；</li><li><strong>缓存失败阶段</strong>：当服务器发现请求的资源已经修改过，或者这是一个新的请求(在本来没有找到资源)，服务器则返回该资源的数据，并且返回 200， 当然这个是指找到资源的情况下，如果服务器上没有这个资源，则返回 404。</li></ul><h4 id="用户操作行为与缓存的关系"><a href="#用户操作行为与缓存的关系" class="headerlink" title="用户操作行为与缓存的关系"></a>用户操作行为与缓存的关系</h4><p>用户在使用浏览器的时候，会有各种操作，比如输入地址后回车，按 F5 刷新等，这些行为会对缓存有什么影响呢？</p><p><img src="/images/browser-action-cache.png" alt=""></p><p>通过上表我们可以看到，当用户在按 F5 进行刷新的时候，会忽略 Expires/Cache-Control 的设置，会再次发送请求去服务器请求，而 Last-Modified/Etag 还是有效的，服务器会根据情况判断返回 304 还是 200；</p><p>而当用户使用 Ctrl+F5 进行强制刷新的时候，只是所有的缓存机制都将失效，重新从服务器拉去资源。</p><ul><li>普通刷新：当按下 F5 或者点击刷新按钮来刷新页面的时候，浏览器将绕过本地缓存来发送请求到服务器, 此时, 协商缓存是有效的</li><li>强制刷新：当按下 ctrl+F5 来刷新页面的时候, 浏览器将绕过各种缓存(本地缓存和协商缓存), 直接让服务器返回最新的资源</li><li>回车或转向：当在地址栏上输入回车或者按下跳转按钮的时候, 所有缓存都生效</li></ul><h4 id="如何从缓存角度改善站点"><a href="#如何从缓存角度改善站点" class="headerlink" title="如何从缓存角度改善站点"></a>如何从缓存角度改善站点</h4><ul><li>同一个资源保证 URL 的稳定性</li><li>给 css、js、图片等资源增加 HTTP 缓存头，并强制入口 html 不被缓存</li><li>减少对 Cookie 的依赖</li><li>减少对 HTTPS 加密协议的使用</li><li>多用 Get 方式请求动态 CGI（公共网关接口（Common Gateway Interface，CGI））</li><li>动态 CGI 也是可以被缓存</li></ul>]]></content>
      
      
      <categories>
          
          <category> Browser </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Browser </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用 React Hooks 获取数据？</title>
      <link href="/how-to-fetch-data-with-react-hooks/"/>
      <url>/how-to-fetch-data-with-react-hooks/</url>
      
        <content type="html"><![CDATA[<p>在本教程中，我想向您展示如何使用 <a href="https://reactjs.org/docs/hooks-state.html" target="_blank" rel="noopener">状态</a>和<a href="https://reactjs.org/docs/hooks-effect.html" target="_blank" rel="noopener">效果</a>挂钩在 React with Hooks 中获取数据。我们将使用广为人知的<a href="https://hn.algolia.com/api" target="_blank" rel="noopener">黑客新闻 API</a>来获取科技界的热门文章。您还将实现数据提取的自定义挂钩，可以在应用程序的任何位置重用，也可以作为独立节点包在 npm 上发布。</p><a id="more"></a><p>如果您对这个新的 React 功能一无所知，请查看<a href="https://www.robinwieruch.de/react-hooks/" target="_blank" rel="noopener">React Hooks</a>的这个<a href="https://www.robinwieruch.de/react-hooks/" target="_blank" rel="noopener">介绍</a>。如果您想要查看完成的项目以获取展示如何在 React with Hooks 中获取数据的展示示例，请检查此<a href="https://github.com/the-road-to-learn-react/react-hooks-introduction" target="_blank" rel="noopener">GitHub 存储库</a>。</p><p><strong>注意：</strong>将来，React Hooks 不适用于 React 中的数据提取。相反，一个名为 Suspense 的功能将负责它。以下演练是了解 React 中有关状态和效果挂钩的更多信息的好方法。</p><h2 id="使用-React-Hooks-获取数据"><a href="#使用-React-Hooks-获取数据" class="headerlink" title="使用 React Hooks 获取数据"></a>使用 React Hooks 获取数据</h2><p>如果您不熟悉 React 中的数据提取，请查看我在<a href="https://www.robinwieruch.de/react-fetching-data/" target="_blank" rel="noopener">React 文章中提取的大量数据</a>。它将引导您完成使用 React 类组件的数据获取，如何使用<a href="https://www.robinwieruch.de/react-render-props-pattern/" target="_blank" rel="noopener">Render Prop 组件</a>和<a href="https://www.robinwieruch.de/gentle-introduction-higher-order-components/" target="_blank" rel="noopener">高阶组件重新获取</a>它，以及它如何处理错误处理和加载微调器。在本文中，我想在功能组件中使用 React Hooks 向您展示所有内容。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;data.hits.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">        &lt;li key=&#123;item.objectID&#125;&gt;</span><br><span class="line">          &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>App 组件显示了一个项目列表（hits = Hacker News 文章）。状态和状态更新函数来自状态钩子<code>useState</code>，它被称为负责管理我们要为 App 组件获取的数据的本地状态。初始状态是表示数据的对象中的空命中列表。目前还没有人为这些数据设置任何状态。</p><p>我们将使用<a href="https://github.com/axios/axios" target="_blank" rel="noopener">axios</a>来获取数据，但是您可以使用另一个数据获取库或浏览器的本机提取 API。如果尚未安装 axios，可以在命令行中执行此操作<code>npm install axios</code>。然后为数据获取实现效果钩子：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> axios(</span><br><span class="line">      <span class="string">"http://hn.algolia.com/api/v1/search?query=redux"</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    setData(result.data);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;data.hits.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">        &lt;li key=&#123;item.objectID&#125;&gt;</span><br><span class="line">          &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>名为 useEffect 的效果挂钩用于从 API 获取带有 axios 的数据，并使用状态挂钩的更新功能将数据设置为组件的本地状态。承诺解决发生在 async / await 中。</p><p>但是，当您运行应用程序时，您应该偶然发现一个讨厌的循环。效果挂钩在组件安装时运行，但也在组件更新时运行。因为我们在每次数据提取后设置状态，所以组件会更新并且效果会再次运行。它一次又一次地获取数据。这是一个错误，需要避免。<strong>我们只想在组件安装时获取数据</strong>。这就是为什么你可以提供一个空数组作为效果钩子的第二个参数，以避免在组件更新时激活它，但仅用于组件的安装。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> axios(</span><br><span class="line">      <span class="string">"http://hn.algolia.com/api/v1/search?query=redux"</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    setData(result.data);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;data.hits.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">        &lt;li key=&#123;item.objectID&#125;&gt;</span><br><span class="line">          &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>第二个参数可用于定义钩子所依赖的所有变量（在此数组中分配）。如果其中一个变量发生变化，则钩子再次运行。如果包含变量的数组为空，则在更新组件时挂钩不会运行，因为它不必监视任何变量。</p><p>还有最后一个问题。在代码中，我们使用 async / await 从第三方 API 获取数据。根据文档，每个使用 async 注释的函数都会返回一个隐式的 promise：“async 函数声明定义了一个异步函数，它返回一个 AsyncFunction 对象。异步函数是一个通过事件循环异步操作的函数，使用隐式 Promise 返回其结果。“。但是，效果挂钩应该不返回任何内容或清除功能。这就是为什么你可能会在开发者控制台日志中看到以下警告：<strong>07：41：22.910 index.js：1452 警告：useEffect 函数必须返回一个清理函数或什么也不返回。不支持 Promises 和 useEffect（async（）=&gt; …），但可以在效果中调用异步函数</strong>。。这就是为什么<code>useEffect</code>不允许在函数中直接使用 async 的原因。让我们通过在效果中使用 async 函数来实现它的解决方法。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> axios(</span><br><span class="line">        <span class="string">"http://hn.algolia.com/api/v1/search?query=redux"</span></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      setData(result.data);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;data.hits.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">        &lt;li key=&#123;item.objectID&#125;&gt;</span><br><span class="line">          &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>li&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>简而言之，就是使用 React 钩子获取数据。但是如果您对错误处理，加载指示符，如何触发从表单中获取数据以及如何实现可重用数据获取挂钩感兴趣，请继续阅读。</p><h2 id="如何以编程方式-手动触发挂钩？"><a href="#如何以编程方式-手动触发挂钩？" class="headerlink" title="如何以编程方式/手动触发挂钩？"></a>如何以编程方式/手动触发挂钩？</h2><p>太好了，我们在组件安装后获取数据。但是如何使用输入字段告诉 API 我们感兴趣的主题？“Redux”被视为默认查询。但是关于“React”的话题呢？让我们实现一个输入元素，使某人能够获取除“Redux”故事之外的其他故事。因此，为 input 元素引入一个新状态。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Fragment, useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">"redux"</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> axios(</span><br><span class="line">        <span class="string">"http://hn.algolia.com/api/v1/search?query=redux"</span></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      setData(result.data);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">"text"</span></span><br><span class="line">        value=&#123;query&#125;</span><br><span class="line">        onChange=&#123;event =&gt; setQuery(event.target.value)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;data.hits.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">          &lt;li key=&#123;item.objectID&#125;&gt;</span><br><span class="line">            &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">          &lt;/</span>li&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Fragment&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>目前，两个状态彼此独立，但现在您希望将它们耦合到仅获取输入字段中查询指定的文章。通过以下更改，组件应在挂载后按查询字词获取所有文章。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">'redux'</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> axios(</span><br><span class="line">        <span class="string">`http://hn.algolia.com/api/v1/search?query=<span class="subst">$&#123;query&#125;</span>`</span>,</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      setData(result.data);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    ...</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>缺少一件：当您尝试在输入字段中键入内容时，在从效果触发安装后没有其他数据获取。那是因为你提供了空数组作为效果的第二个参数。效果取决于无变量，因此仅在组件安装时触发。但是，现在效果应该取决于查询。查询更改后，数据请求将再次触发。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">'redux'</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> axios(</span><br><span class="line">        <span class="string">`http://hn.algolia.com/api/v1/search?query=<span class="subst">$&#123;query&#125;</span>`</span>,</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      setData(result.data);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, [query]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    ...</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>一旦更改输入字段中的值，就可以重新获取数据。但这会带来另一个问题：在输入字段中键入的每个字符上，都会触发效果并执行另一个数据提取请求。如何提供一个按钮来触发请求，从而手动挂钩？</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">"redux"</span>);</span><br><span class="line">  <span class="keyword">const</span> [search, setSearch] = useState(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> axios(</span><br><span class="line">        <span class="string">`http://hn.algolia.com/api/v1/search?query=<span class="subst">$&#123;query&#125;</span>`</span></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      setData(result.data);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, [query]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">"text"</span></span><br><span class="line">        value=&#123;query&#125;</span><br><span class="line">        onChange=&#123;event =&gt; setQuery(event.target.value)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;button type=<span class="string">"button"</span> onClick=&#123;() =&gt; setSearch(query)&#125;&gt;</span><br><span class="line">        Search</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">        &#123;data.hits.map(item =&gt; (</span></span><br><span class="line"><span class="regexp">          &lt;li key=&#123;item.objectID&#125;&gt;</span></span><br><span class="line"><span class="regexp">            &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/</span>a&gt;</span><br><span class="line">          &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        ))&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/u</span>l&gt;</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>现在，使效果取决于搜索状态，而不是随输入字段中的每个键击更改的波动查询状态。用户单击该按钮后，将设置新的搜索状态，并应手动触发效果挂钩。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">'redux'</span>);</span><br><span class="line">  <span class="keyword">const</span> [search, setSearch] = useState(<span class="string">'redux'</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> axios(</span><br><span class="line">        <span class="string">`http://hn.algolia.com/api/v1/search?query=<span class="subst">$&#123;search&#125;</span>`</span>,</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      setData(result.data);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, [search]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    ...</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>此外，搜索状态的初始状态设置为与查询状态相同的状态，因为组件也在 mount 上获取数据，因此结果应该镜像输入字段中的值。但是，具有类似的查询和搜索状态有点令人困惑。为什么不将实际的 URL 设置为状态而不是搜索状态？</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">"redux"</span>);</span><br><span class="line">  <span class="keyword">const</span> [url, setUrl] = useState(</span><br><span class="line">    <span class="string">"http://hn.algolia.com/api/v1/search?query=redux"</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> axios(url);</span><br><span class="line"></span><br><span class="line">      setData(result.data);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, [url]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">"text"</span></span><br><span class="line">        value=&#123;query&#125;</span><br><span class="line">        onChange=&#123;event =&gt; setQuery(event.target.value)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        type=<span class="string">"button"</span></span><br><span class="line">        onClick=&#123;() =&gt;</span><br><span class="line">          setUrl(<span class="string">`http://hn.algolia.com/api/v1/search?query=<span class="subst">$&#123;query&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &gt;</span><br><span class="line">        Search</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">        &#123;data.hits.map(item =&gt; (</span></span><br><span class="line"><span class="regexp">          &lt;li key=&#123;item.objectID&#125;&gt;</span></span><br><span class="line"><span class="regexp">            &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/</span>a&gt;</span><br><span class="line">          &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        ))&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/u</span>l&gt;</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这就是使用效果钩子获取隐式程序数据的情况。您可以决定效果所依赖的状态。一旦您在单击或其他副作用中设置此状态，此效果将再次运行。在这种情况下，如果 URL 状态发生更改，则效果会再次运行以从 API 获取故事。</p><h2 id="装载指示器与反应钩"><a href="#装载指示器与反应钩" class="headerlink" title="装载指示器与反应钩"></a>装载指示器与反应钩</h2><p>让我们为数据提取引入一个加载指示器。它只是另一个由状态钩子管理的状态。加载标志用于在 App 组件中呈现加载指示符。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Fragment, useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">"redux"</span>);</span><br><span class="line">  <span class="keyword">const</span> [url, setUrl] = useState(</span><br><span class="line">    <span class="string">"http://hn.algolia.com/api/v1/search?query=redux"</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> [isLoading, setIsLoading] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      setIsLoading(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> axios(url);</span><br><span class="line"></span><br><span class="line">      setData(result.data);</span><br><span class="line">      setIsLoading(<span class="literal">false</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, [url]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">"text"</span></span><br><span class="line">        value=&#123;query&#125;</span><br><span class="line">        onChange=&#123;event =&gt; setQuery(event.target.value)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        type=<span class="string">"button"</span></span><br><span class="line">        onClick=&#123;() =&gt;</span><br><span class="line">          setUrl(<span class="string">`http://hn.algolia.com/api/v1/search?query=<span class="subst">$&#123;query&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &gt;</span><br><span class="line">        Search</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      &#123;isLoading ? (</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;Loading ...&lt;/</span>div&gt;</span><br><span class="line">      ) : (</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123;data.hits.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">            &lt;li key=&#123;item.objectID&#125;&gt;</span><br><span class="line">              &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>li&gt;</span><br><span class="line">          ))&#125;</span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      )&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Fragment&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>一旦为数据提取调用了效果，这在组件安装或 URL 状态更改时发生，则加载状态设置为 true。请求解析后，加载状态再次设置为 false。</p><h2 id="使用-React-Hook-进行错误处理"><a href="#使用-React-Hook-进行错误处理" class="headerlink" title="使用 React Hook 进行错误处理"></a>使用 React Hook 进行错误处理</h2><p>使用 React 钩子获取数据的错误处理怎么样？错误只是用状态挂钩初始化的另一个状态。一旦出现错误状态，App 组件就可以为用户呈现反馈。使用 async / await 时，通常使用 try / catch 块进行错误处理。你可以在效果范围内完成：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Fragment, useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">"redux"</span>);</span><br><span class="line">  <span class="keyword">const</span> [url, setUrl] = useState(</span><br><span class="line">    <span class="string">"http://hn.algolia.com/api/v1/search?query=redux"</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> [isLoading, setIsLoading] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> [isError, setIsError] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      setIsError(<span class="literal">false</span>);</span><br><span class="line">      setIsLoading(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> axios(url);</span><br><span class="line"></span><br><span class="line">        setData(result.data);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        setIsError(<span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      setIsLoading(<span class="literal">false</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, [url]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">"text"</span></span><br><span class="line">        value=&#123;query&#125;</span><br><span class="line">        onChange=&#123;event =&gt; setQuery(event.target.value)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        type=<span class="string">"button"</span></span><br><span class="line">        onClick=&#123;() =&gt;</span><br><span class="line">          setUrl(<span class="string">`http://hn.algolia.com/api/v1/search?query=<span class="subst">$&#123;query&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &gt;</span><br><span class="line">        Search</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      &#123;isError &amp;&amp; &lt;div&gt;Something went wrong ...&lt;/</span>div&gt;&#125;</span><br><span class="line"></span><br><span class="line">      &#123;isLoading ? (</span><br><span class="line">        &lt;div&gt;Loading ...&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      ) : (</span></span><br><span class="line"><span class="regexp">        &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">          &#123;data.hits.map(item =&gt; (</span></span><br><span class="line"><span class="regexp">            &lt;li key=&#123;item.objectID&#125;&gt;</span></span><br><span class="line"><span class="regexp">              &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/</span>a&gt;</span><br><span class="line">            &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">          ))&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/u</span>l&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>每次挂钩再次运行时，错误状态都会重置。这很有用，因为在失败的请求之后，用户可能想要再次尝试它，这应该重置错误。为了自己执行错误，您可以将 URL 更改为无效的内容。然后检查错误消息是否显示。</p><h2 id="使用表单获取数据并进行反应"><a href="#使用表单获取数据并进行反应" class="headerlink" title="使用表单获取数据并进行反应"></a>使用表单获取数据并进行反应</h2><p>获取数据的正确表单怎么样？到目前为止，我们只有输入字段和按钮的组合。一旦引入了更多输入元素，您可能希望用表单元素包装它们。此外，表单也可以通过键盘上的“Enter”触发按钮。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;form</span><br><span class="line">        onSubmit=&#123;() =&gt;</span><br><span class="line">          setUrl(<span class="string">`http://hn.algolia.com/api/v1/search?query=<span class="subst">$&#123;query&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"text"</span></span><br><span class="line">          value=&#123;query&#125;</span><br><span class="line">          onChange=&#123;event =&gt; setQuery(event.target.value)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;button type=<span class="string">"submit"</span>&gt;Search&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line"></span><br><span class="line">      &#123;isError &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Something went wrong ...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>但是现在浏览器在单击提交按钮时会重新加载，因为这是提交表单时浏览器的本机行为。为了防止默认行为，我们可以在 React 事件上调用一个函数。这就是你在 React 类组件中的表现。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> doFetch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setUrl(<span class="string">`http://hn.algolia.com/api/v1/search?query=<span class="subst">$&#123;query&#125;</span>`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;form onSubmit=&#123;event =&gt; &#123;</span><br><span class="line">        doFetch();</span><br><span class="line"></span><br><span class="line">        event.preventDefault();</span><br><span class="line">      &#125;&#125;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"text"</span></span><br><span class="line">          value=&#123;query&#125;</span><br><span class="line">          onChange=&#123;event =&gt; setQuery(event.target.value)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;button type=<span class="string">"submit"</span>&gt;Search&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line"></span><br><span class="line">      &#123;isError &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Something went wrong ...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>现在，当您单击“提交”按钮时，浏览器不应再重新加载。它像以前一样工作，但这次是使用表单而不是天真的输入字段和按钮组合。您也可以按键盘上的“Enter”键。</p><h2 id="自定义数据获取钩子"><a href="#自定义数据获取钩子" class="headerlink" title="自定义数据获取钩子"></a>自定义数据获取钩子</h2><p>为了提取数据提取的自定义挂钩，将属于数据提取的所有内容（属于输入字段的查询状态除外，包括加载指示符和错误处理）移动到其自己的函数中。还要确保从 App 组件中使用的函数返回所有必需的变量。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> useHackerNewsApi = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">  <span class="keyword">const</span> [url, setUrl] = useState(</span><br><span class="line">    <span class="string">"http://hn.algolia.com/api/v1/search?query=redux"</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> [isLoading, setIsLoading] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> [isError, setIsError] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      setIsError(<span class="literal">false</span>);</span><br><span class="line">      setIsLoading(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> axios(url);</span><br><span class="line"></span><br><span class="line">        setData(result.data);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        setIsError(<span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      setIsLoading(<span class="literal">false</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, [url]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> doFetch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setUrl(<span class="string">`http://hn.algolia.com/api/v1/search?query=<span class="subst">$&#123;query&#125;</span>`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; data, isLoading, isError, doFetch &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，您的新挂钩可以再次在 App 组件中使用：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">"redux"</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123; data, isLoading, isError, doFetch &#125; = useHackerNewsApi();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Fragment</span>&gt;</span>...<span class="tag">&lt;/<span class="name">Fragment</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，从<code>doFetch</code>函数外部传递 URL 状态：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> useHackerNewsApi = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  useEffect(</span><br><span class="line">    ...</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> doFetch = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">    setUrl(url);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; data, isLoading, isError, doFetch &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">'redux'</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123; data, isLoading, isError, doFetch &#125; = useHackerNewsApi();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;form</span><br><span class="line">        onSubmit=&#123;event =&gt; &#123;</span><br><span class="line">          doFetch(</span><br><span class="line">            <span class="string">`http://hn.algolia.com/api/v1/search?query=<span class="subst">$&#123;query&#125;</span>`</span>,</span><br><span class="line">          );</span><br><span class="line"></span><br><span class="line">          event.preventDefault();</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"text"</span></span><br><span class="line">          value=&#123;query&#125;</span><br><span class="line">          onChange=&#123;event =&gt; setQuery(event.target.value)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;button type=<span class="string">"submit"</span>&gt;Search&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>初始状态也可以是通用的。将它简单地传递给新的自定义钩子：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Fragment, useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useDataApi = <span class="function">(<span class="params">initialUrl, initialData</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(initialData);</span><br><span class="line">  <span class="keyword">const</span> [url, setUrl] = useState(initialUrl);</span><br><span class="line">  <span class="keyword">const</span> [isLoading, setIsLoading] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> [isError, setIsError] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      setIsError(<span class="literal">false</span>);</span><br><span class="line">      setIsLoading(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> axios(url);</span><br><span class="line"></span><br><span class="line">        setData(result.data);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        setIsError(<span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      setIsLoading(<span class="literal">false</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, [url]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> doFetch = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">    setUrl(url);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; data, isLoading, isError, doFetch &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">"redux"</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123; data, isLoading, isError, doFetch &#125; = useDataApi(</span><br><span class="line">    <span class="string">"http://hn.algolia.com/api/v1/search?query=redux"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      hits: []</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;form</span><br><span class="line">        onSubmit=&#123;event =&gt; &#123;</span><br><span class="line">          doFetch(<span class="string">`http://hn.algolia.com/api/v1/search?query=<span class="subst">$&#123;query&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">          event.preventDefault();</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"text"</span></span><br><span class="line">          value=&#123;query&#125;</span><br><span class="line">          onChange=&#123;event =&gt; setQuery(event.target.value)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;button type=<span class="string">"submit"</span>&gt;Search&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line"></span><br><span class="line">      &#123;isError &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Something went wrong ...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;</span><br><span class="line"></span><br><span class="line">      &#123;isLoading ? (</span><br><span class="line">        &lt;div&gt;Loading ...&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      ) : (</span></span><br><span class="line"><span class="regexp">        &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">          &#123;data.hits.map(item =&gt; (</span></span><br><span class="line"><span class="regexp">            &lt;li key=&#123;item.objectID&#125;&gt;</span></span><br><span class="line"><span class="regexp">              &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/</span>a&gt;</span><br><span class="line">            &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">          ))&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/u</span>l&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>这就是使用自定义钩子获取数据的原因。钩子本身对 API 没有任何了解。它从外部接收所有参数，并仅管理必要的状态，例如数据，加载和错误状态。它执行请求并使用它作为自定义数据获取挂钩将数据返回给组件。</p><h2 id="用于数据获取的-Reducer-Hook"><a href="#用于数据获取的-Reducer-Hook" class="headerlink" title="用于数据获取的 Reducer Hook"></a>用于数据获取的 Reducer Hook</h2><p>到目前为止，我们已经使用各种状态挂钩来管理数据，加载和错误状态的数据获取状态。然而，不知何故，所有这些状态，由他们自己的状态钩子管理，属于一起，因为他们关心相同的原因。如您所见，它们都在数据提取功能中使用。一个很好的指标，他们属于一起的是，它们用于一个接一个（例如<code>setIsError</code>，<code>setIsLoading</code>）。让我们将所有这三个与 Reducer Hook 结合起来。</p><p>Reducer Hook 返回一个状态对象和一个改变状态对象的函数。该函数（称为调度函数）采用具有类型和可选有效负载的操作。所有这些信息都在实际的 reducer 函数中用于从先前的状态，动作的可选有效负载和类型中提取新状态。让我们看看它在代码中是如何工作的：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;</span><br><span class="line">  Fragment,</span><br><span class="line">  useState,</span><br><span class="line">  useEffect,</span><br><span class="line">  useReducer,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dataFetchReducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useDataApi = <span class="function">(<span class="params">initialUrl, initialData</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [url, setUrl] = useState(initialUrl);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(dataFetchReducer, &#123;</span><br><span class="line">    isLoading: <span class="literal">false</span>,</span><br><span class="line">    isError: <span class="literal">false</span>,</span><br><span class="line">    data: initialData,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Reducer Hook 将 reducer 函数和初始状态对象作为参数。在我们的例子中，数据，加载和错误状态的初始状态的参数没有改变，但它们已经聚合到一个由一个 reducer 钩子而不是单个状态钩子管理的状态对象。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dataFetchReducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useDataApi = <span class="function">(<span class="params">initialUrl, initialData</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [url, setUrl] = useState(initialUrl);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(dataFetchReducer, &#123;</span><br><span class="line">    isLoading: <span class="literal">false</span>,</span><br><span class="line">    isError: <span class="literal">false</span>,</span><br><span class="line">    data: initialData,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      dispatch(&#123; <span class="attr">type</span>: <span class="string">'FETCH_INIT'</span> &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> axios(url);</span><br><span class="line"></span><br><span class="line">        dispatch(&#123; <span class="attr">type</span>: <span class="string">'FETCH_SUCCESS'</span>, <span class="attr">payload</span>: result.data &#125;);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        dispatch(&#123; <span class="attr">type</span>: <span class="string">'FETCH_FAILURE'</span> &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, [url]);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，在获取数据时，可以使用调度功能将信息发送到 reducer 功能。使用 dispatch 函数发送的对象具有强制<code>type</code>属性和可选<code>payload</code>属性。该类型告诉 reducer 功能需要应用哪个状态转换，并且 reducer 可以另外使用有效负载来提取新状态。毕竟，我们只有三个状态转换：初始化提取过程，通知成功的数据提取结果，并通知有关错误的数据提取结果。</p><p>在自定义钩子的末尾，状态像以前一样返回，但是因为我们有状态对象而不是独立状态，所以状态对象作为被破坏对象返回。这样，调用<code>useDataApi</code>自定义挂钩的人仍然可以访问<code>data</code>，<code>isLoading</code>并且<code>isError</code>：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> useDataApi = <span class="function">(<span class="params">initialUrl, initialData</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [url, setUrl] = useState(initialUrl);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(dataFetchReducer, &#123;</span><br><span class="line">    isLoading: <span class="literal">false</span>,</span><br><span class="line">    isError: <span class="literal">false</span>,</span><br><span class="line">    data: initialData,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> doFetch = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">    setUrl(url);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; ...state, doFetch &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后但并非最不重要的是，缺少 reducer 函数的实现。它需要作用于所谓的三种不同的状态转换<code>FETCH_INIT</code>，<code>FETCH_SUCCESS</code>和<code>FETCH_FAILURE</code>。每个状态转换都需要返回一个新的状态对象。让我们看看如何使用 switch case 语句实现它：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dataFetchReducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"FETCH_INIT"</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"FETCH_SUCCESS"</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"FETCH_FAILURE"</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reducer 函数可以通过其参数访问当前状态和传入操作。到目前为止，在 out case case 语句中，每个状态转换仅返回先前的状态。解构语句用于保持状态对象不可变 - 意味着状态永远不会直接变异 - 以强制执行最佳实践。现在让我们覆盖一些当前状态返回的属性来改变每个状态转换的状态：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dataFetchReducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"FETCH_INIT"</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        isLoading: <span class="literal">true</span>,</span><br><span class="line">        isError: <span class="literal">false</span></span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"FETCH_SUCCESS"</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        isLoading: <span class="literal">false</span>,</span><br><span class="line">        isError: <span class="literal">false</span>,</span><br><span class="line">        data: action.payload</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"FETCH_FAILURE"</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        isLoading: <span class="literal">false</span>,</span><br><span class="line">        isError: <span class="literal">true</span></span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，由动作类型决定的每个状态转换都会返回基于先前状态和可选有效负载的新状态。例如，在成功请求的情况下，有效载荷用于设置新状态对象的数据。</p><p>总之，Reducer Hook 确保状态管理的这一部分用自己的逻辑封装。通过提供操作类型和可选的有效负载，您将始终以谓词状态更改结束。此外，您永远不会遇到无效状态。例如，以前可能会意外地将<code>isLoading</code>和<code>isError</code>状态设置为 true。在这种情况下，UI 应该显示什么？现在，reducer 函数定义的每个状态转换都会导致一个有效的状态对象。</p><h2 id="中止数据在效果钩中获取"><a href="#中止数据在效果钩中获取" class="headerlink" title="中止数据在效果钩中获取"></a>中止数据在效果钩中获取</h2><p>React 中的一个常见问题是即使组件已经卸载（例如由于使用 React Router 导航），也会设置组件状态。我之前在这里写过关于这个问题的文章，它描述了<a href="https://www.robinwieruch.de/react-warning-cant-call-setstate-on-an-unmounted-component/" target="_blank" rel="noopener">如何防止</a>在各种场景中为<a href="https://www.robinwieruch.de/react-warning-cant-call-setstate-on-an-unmounted-component/" target="_blank" rel="noopener">未安装的组件</a>设置状态。让我们看看我们如何阻止在数据提取的自定义钩子中设置状态：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> useDataApi = <span class="function">(<span class="params">initialUrl, initialData</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [url, setUrl] = useState(initialUrl);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(dataFetchReducer, &#123;</span><br><span class="line">    isLoading: <span class="literal">false</span>,</span><br><span class="line">    isError: <span class="literal">false</span>,</span><br><span class="line">    data: initialData</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> didCancel = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      dispatch(&#123; <span class="attr">type</span>: <span class="string">"FETCH_INIT"</span> &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> axios(url);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!didCancel) &#123;</span><br><span class="line">          dispatch(&#123; <span class="attr">type</span>: <span class="string">"FETCH_SUCCESS"</span>, <span class="attr">payload</span>: result.data &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!didCancel) &#123;</span><br><span class="line">          dispatch(&#123; <span class="attr">type</span>: <span class="string">"FETCH_FAILURE"</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      didCancel = <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [url]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> doFetch = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">    setUrl(url);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; ...state, doFetch &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个效果挂钩都带有一个清理功能，该功能在组件卸载时运行。清理功能是钩子返回的一个功能。在我们的例子中，我们使用一个布尔标志来调用<code>didCancel</code>，让我们的数据获取逻辑知道组件的状态（已安装/未安装）。如果组件已卸载，则应将该标志设置为<code>true</code>导致在最终异步解析数据提取后阻止设置组件状态。</p><p>注意：实际上不会中止数据获取 - 这可以通过<a href="https://github.com/axios/axios#cancellation" target="_blank" rel="noopener">Axios Cancellation</a>实现- 但是对于未安装的组件不再执行状态转换。由于 Axios Cancellation 在我看来并不是最好的 API，因此这个防止设置状态的布尔标志也能完成这项工作。</p><p>您已经了解了如何在 React 中使用状态和效果的 React 挂钩进行数据获取。如果您对使用渲染道具和高阶组件的类组件（和函数组件）中的数据获取感到好奇，请从头开始查看我的其他文章。否则，我希望本文对您了解 React Hooks 以及如何在现实世界中使用它们非常有用。</p><p><strong>译文：</strong><a href="https://www.robinwieruch.de/react-hooks-fetch-data/" target="_blank" rel="noopener">How to fetch data with React Hooks?</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 内存管理</title>
      <link href="/js-memory-management/"/>
      <url>/js-memory-management/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是内存泄漏？"><a href="#什么是内存泄漏？" class="headerlink" title="什么是内存泄漏？"></a>什么是内存泄漏？</h2><p><img src="/images/js-memory-management-5.png" alt=""></p><p>当我们决定不再使用某些内存时，由于错误的编码，未能使得 GC(Garbage Collection)正确的将这些内存回收的情况，就是内存泄漏。</p><a id="more"></a><h2 id="内存的占用"><a href="#内存的占用" class="headerlink" title="内存的占用"></a>内存的占用</h2><p>一个对象占用的内存分为直接占用内存(Shallow Size)和占用总内存(Retained Size)，赋值和 New 操作都会涉及到内存的占用。</p><ul><li>直接占用内存：对象本身占用的内存。典型的 JavaScript 对象都会有保留内存用来描述这个对象和存储它的直接值。一般，只有数组和字符串会有明显的直接占用内存(Shallow Size)。但字符串和数组常常会在渲染器内存中存储主要数据部分，仅仅在 JavaScript 对象栈中暴露一个很小的包装对象。</li><li>占用总内存：直接占用内存和这个引用的依赖对象所占用的内存。</li></ul><h2 id="内存的分配"><a href="#内存的分配" class="headerlink" title="内存的分配"></a>内存的分配</h2><p>Chrome V8 的垃圾回收（GC）算法基于 Generational Collection，内存被划分为两种，分别称为 Young Generation（YG）和 Old Generation（OG）。</p><blockquote><p>所谓 Young 和 Old 是根据他们占用的时间来划分的。内存在 YG 的分配和回收快而频繁，一般存在的时间很短，所以称为 Young；而在 OG 中则慢而少发生，所以称为 Old。</p></blockquote><p>因为在 V8 中，YG 的 GC 过程会阻塞程序，而 OG 的 GC 不会阻塞。所以通常情况下开发者更关心 YG 的细节。</p><p>YG 又被平分为两部分空间，分别称为 From 和 To。所有内存从 To 空间被分配出去，当 To 满时，开始触发 GC，接下来细看一下。</p><p>某时刻，To 已经分 A、B 和 C 分配了内存，当前它剩下一小块内存未分配出去，而 From 所有的内存都空闲着。</p><p><img src="/images/js-memory-management-1.png" alt=""></p><p>此时，一个程序需要为 D 分配内存，但 D 需要的内存大小超出了 To 未分配的内存，如下图。此时，触发 GC，页面停止执行。</p><p><img src="/images/js-memory-management-2.png" alt=""></p><p>接着 From 和 To 进行对换，即原来的 To 空间被标志为 From，From 被标志为 To。并且把活的变量值（例如 B）标志出来，而”垃圾“（例如 AC）未被标志，它们将会被清掉。</p><p><img src="/images/js-memory-management-3.png" alt=""></p><p>活的 B 会被复制到 To 空间，而「垃圾」AC 则被回收，同时，D 被分配到 To 空间，最后成下图的分布</p><p><img src="/images/js-memory-management-4.png" alt=""></p><p>至此，整个 GC 完成，此过程中页面停止执行，所以要尽可能的快。当 YG 中的值存活比较久时，它会被推向 OG，OG 的空间满时，触发 OG 内的 GC，OG 的 GC 时会触发 YG 的 GC。</p><ul><li>每次分配都使 To 的可用空间减小，程序又更接近 GC</li><li>YG 的 GC 会阻塞程序，所以 GC 时间不宜太长 10ms 以内，因为 16ms 就会出现丢帧；GC 不宜太频繁</li><li>某个值变成垃圾后，不会立马释放内存，只有在 GC 的时候所占内存才会被回收。</li></ul><h2 id="内存的回收"><a href="#内存的回收" class="headerlink" title="内存的回收"></a>内存的回收</h2><p>GC Root 是内存的根结节，在浏览器中它是 window，在 NodeJS 中则是 global 对象。</p><p><img src="/images/js-memory-management-5.png" alt=""></p><p>从 GC Root 开始遍历图，所有能到达的节点称为活节点，如果存在 GC Root 不能到达的节点，那么该节点称为“垃圾”，将会被回收，如图中灰色的节点。</p><p>至于根节点的回收，不受用户的控制。</p><h2 id="导致内存泄漏的原因"><a href="#导致内存泄漏的原因" class="headerlink" title="导致内存泄漏的原因"></a>导致内存泄漏的原因</h2><h3 id="没有完全切断与-GC-root-之间的路径"><a href="#没有完全切断与-GC-root-之间的路径" class="headerlink" title="没有完全切断与 GC root 之间的路径"></a>没有完全切断与 GC root 之间的路径</h3><p>因为没有完全切断与根节点之间的路径，导致自动 GC 不会回收这部分内存，从而造成内存泄漏。</p><ul><li><p>对象之间的相互引用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line">a.reference = b;</span><br><span class="line">b.reference = a;</span><br></pre></td></tr></table></figure></li><li><p>错误使用了全局变量</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = <span class="string">"1234567"</span>;</span><br><span class="line">相当于;</span><br><span class="line"><span class="built_in">window</span>.a = <span class="string">"1234567"</span>;</span><br></pre></td></tr></table></figure></li><li><p>DOM 元素清空或删除时，绑定的事件未清除</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click me"</span> <span class="attr">id</span>=<span class="string">"myBtn"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span></span><br><span class="line"><span class="actionscript">  btn.onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).innerHTML = <span class="string">"Processing..."</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">/* 清除事件绑定 */</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// btn.onclick = null;</span></span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>闭包引用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">document</span>.getElementById(<span class="string">"xxx"</span>);</span><br><span class="line"></span><br><span class="line">  obj.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">/** 空函数*/</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** delete this reference */</span></span><br><span class="line">  <span class="comment">// obj = null;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>DOM 元素清空或删除时，子元素存在 JS 引用，导致子元素的所有父元素都不会被删除</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b是a的子dom节点, a是body的子节点</span></span><br><span class="line"><span class="keyword">var</span> aElement = <span class="built_in">document</span>.getElementById(<span class="string">"a"</span>);</span><br><span class="line"><span class="keyword">var</span> bElement = <span class="built_in">document</span>.getElementById(<span class="string">"b"</span>);</span><br><span class="line"><span class="built_in">document</span>.body.removeChild(aElement);</span><br><span class="line"><span class="comment">// aElement = null；</span></span><br><span class="line"><span class="comment">// bElement = null;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="过度占用了内存空间"><a href="#过度占用了内存空间" class="headerlink" title="过度占用了内存空间"></a>过度占用了内存空间</h3><p>更多的出现在 nodejs 中，例如：</p><ul><li>无节制的循环<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// do sth</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>过大的数组<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = &#123;</span><br><span class="line">    desc: <span class="string">"an object"</span></span><br><span class="line">  &#125;;</span><br><span class="line">  arr.push(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://www.codeceo.com/article/chrome-javascript-memory.html" target="_blank" rel="noopener">《Chrome 开发者工具之 JavaScript 内存分析》</a></p>]]></content>
      
      
      <categories>
          
          <category> Browser </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Web Development </tag>
            
            <tag> Storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>覆盖模式-提高 React 组件的复用率</title>
      <link href="/overrides-mode/"/>
      <url>/overrides-mode/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>如果你在过去几年中一直在关注 React 生态系统，那么在众多用于开发人员在构建应用程序时可以使用的<a href="https://hackernoon.com/23-best-react-ui-component-libraries-and-frameworks-250a81b2ac42" target="_blank" rel="noopener">开源可重用组件库</a>中，你至少曾尝试或听说过一个。这些库使我们不必再为每个应用程序反复构建相同的模态，菜单和表单控件。</p><a id="more"></a><p>那些曾经使用过其中一个库的人可能也遇到过一个组件不太适合你需要的场景，也许是组件的设计和你需要的不要一样，并且那些组件没有暴露出可以配置样式的 API；又或许是你只是想要一个样式自定义的复选框。</p><p>这在我们优步是一个很常见的情绪了，由于团队经常被迫开始构建一个新的组件，这导致了很多无谓的浪费。因此，当我们最近着手改造我们心爱（但老旧）的组件库的时候，我们调查了数十位工程师，以便更好地了解他们在复用现有的组件时遇到的障碍。有几点很明确：</p><ul><li><strong>Styles:</strong> 开发者需要能够配置组件及其内部组件的样式。这对于 global CSS 或许很容易，但是在 CSS-in-JS 的世界中，每个元素都可以有任意类封装在组件之中，想要实现就变得十分的困难了。</li><li><strong>Props:</strong> 有时候你只是需要改变传递给内部组件的 props。例如给元素添加一个<code>aria-label</code>属性，或者是在集成测试中将<code>className</code>传递给指定的目标。</li><li><strong>Render:</strong> 在很多情况下，人们只是希望能够完全覆盖某些内部的渲染或行为——例如，想添加到日期选择器添加一个快捷选择的选项（如：“过去 30 天”）。</li></ul><p>我们当然不是第一个试图去解决这些问题的人。在 React 社区中推广的<a href="https://reactjs.org/docs/render-props.html" target="_blank" rel="noopener">render props</a>模式是一种允许更多方法控制一个组件渲染方式的策略。Paypal 的<a href="https://github.com/paypal/downshift" target="_blank" rel="noopener">downshift</a> 也是一个很好的例子，这使你可以明确如果使用 render props 可以达成的效果。</p><p>但是 render props 对于许多情况来说都是一个很好的工具，如果你只是想覆盖一个样式或者改变一些内部元素的 props，这样做可能就有点沉重了。类似的，组件作者有时候会提供像是<em>getFooStyle</em>或<em>getFooProps</em>这样的 props 来定制一些内部元素，但是这些很少以一致的方式提供给所有的内部组件。</p><p>我们希望在我们的组件中提供一个统一的 API，它提供了渲染所有的灵活方式，但同时有可以有捷径，适用于只需要覆盖一些内部样式或 props 非常频繁的场景。</p><p>我们提出的解决方案称之为“Overrides”模式（覆盖模式）。它仍在不断发展，但到目前为止，我们对开发人员使用它的方法感到印象深刻。我们希望与更广泛的社区分享，希望它能激发其他组件库作者的兴趣，或者至少提高对组件复用性当前缺陷的认识。下面将展示它是如何实现的。</p><h1 id="覆盖公共的-API"><a href="#覆盖公共的-API" class="headerlink" title="覆盖公共的 API"></a>覆盖公共的 API</h1><p>下面的代码片段演示了覆盖模式在可复用 Autocomplete 组件的具体实现：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line">render() &#123;</span><br><span class="line">  &lt;Autocomplete</span><br><span class="line">    options=&#123;<span class="keyword">this</span>.props.products&#125;</span><br><span class="line">    overrides=&#123;&#123;</span><br><span class="line">      Root: &#123;</span><br><span class="line">        props: &#123;<span class="string">'aria-label'</span>: <span class="string">'Select an option'</span>&#125;,</span><br><span class="line">        style: <span class="function">(<span class="params">&#123;$isOpen&#125;</span>) =&gt;</span> (&#123;<span class="attr">borderColor</span>: $isOpen ? <span class="string">'blue'</span> : <span class="string">'grey'</span>&#125;),</span><br><span class="line">      &#125;,</span><br><span class="line">      Option: &#123;</span><br><span class="line">        component: CustomOption</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CustomOption.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">CustomOption</span>(<span class="params">&#123;onClick, $option&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div onClick=&#123;onClick&#125;&gt;</span><br><span class="line">      &lt;h4&gt;&#123;$option.name&#125;&lt;<span class="regexp">/h4&gt;</span></span><br><span class="line"><span class="regexp">      &lt;small&gt;&#123;$option.price&#125;&lt;/</span>small&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line">// https://gist.github.com/schnerd/045ee729696f0352bb106b186eb50855#file-overrides-example-public-js</span><br></pre></td></tr></table></figure><p>这里有很多内容，让我们来看看一些关键的变化：</p><ul><li>每一个内部元素都有一个开发者可以定位的标识符。这里我们使用的是<em>Root</em>和<em>Option</em>。你几乎可以将这些视为类名（但没有 CSS 级联和全局命名空间的缺点）</li><li>对于每个内部元素，你都可以覆盖<strong>props</strong>，<strong>style</strong>，和<strong>component</strong>.</li><li>覆盖 props 非常直接，你指定的对象将使用默认道具传递，并优先于它们。在这种情况下，你可以看到我们正在使用它在 Root 元素上来添加<code>aria-label</code>。</li><li>当覆盖<strong>style</strong>时，你可以传递一个样式对象或者接受与组件当前内部状态相关的一些道具的函数，允许你更具组件状态动态地更改样式，如<code>isError</code>或<code>isSelected</code>。函数返回的样式对象与默认元素样式深度合并。</li><li>当覆盖<strong>component</strong>时，可以传入无状态功能组件或 React 组件类，你可以在其中以供自己的渲染逻辑，也可以选择添加其他处理程序或行为。这实际上是依赖注入，并解锁了更多可能性。</li></ul><p>通过一个统一的<code>overrides</code>支柱提供所有这些功能，为开发人员提供了一个一致的方法定制所需内容。</p><h1 id="覆盖组件行为"><a href="#覆盖组件行为" class="headerlink" title="覆盖组件行为"></a>覆盖组件行为</h1><p>为了让你了解我们团队如何使用此功能，以下是优步货运团队的一个示例：</p><p>他们想要使用同一个 API、键盘控制和事件为一个 radio 组来创建表单元素，但是有不同的视觉外观。他们能够在我们现有的<code>RadioGroup</code>组件添加一系列样式覆盖，而不必浪费地构建，测试和维护他们自己的自定义实现。</p><p>我们在对此模式进行原型设计时使用的另一个示例是向多选组件中的标记添加编辑行为。在这种情况下，我们创建了一个组件覆盖<code>Tag</code>，为其渲染了现有的内容，同是注入了一个编辑标签。</p><p>这说明了与 render props 相比允许注入完整组件的一个好处——你可以创建新的状态，生命周期方法，如果你需要的话甚至可以使用 React Hooks。我们的<code>EditableTag</code>组件在单击时能够显示模态，然后触发必要的 redux 操作以更新标记的名称。</p><h1 id="覆盖内部实施（组件）"><a href="#覆盖内部实施（组件）" class="headerlink" title="覆盖内部实施（组件）"></a>覆盖内部实施（组件）</h1><p>以下是我们 Autocomplete 组件内部可以实现的覆盖方法：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Autocomplete.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> defaultComponents <span class="keyword">from</span> <span class="string">'./styled-elements'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Autocomplete</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Setup &amp; handlers omitted to keep this example short</span></span><br><span class="line"></span><br><span class="line">  getSharedStyleProps() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;isOpen, isError&#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      $isOpen: isOpen</span><br><span class="line">      $isError: isError</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;isOpen, query, value&#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">const</span> &#123;options, overrides&#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      Root: &#123;<span class="attr">component</span>: Root, <span class="attr">props</span>: rootProps&#125;,</span><br><span class="line">      Input: &#123;<span class="attr">component</span>: Input, <span class="attr">props</span>: inputProps&#125;,</span><br><span class="line">      List: &#123;<span class="attr">component</span>: List, <span class="attr">props</span>: listProps&#125;,</span><br><span class="line">      Option: &#123;<span class="attr">component</span>: Option, <span class="attr">props</span>: optionProps&#125;,</span><br><span class="line">    &#125; = getComponents(defaultComponents, overrides);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> sharedProps = <span class="keyword">this</span>.getSharedStyleProps();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Root &#123;...sharedProps&#125; &#123;...rootProps&#125;&gt;</span><br><span class="line">        &lt;Input</span><br><span class="line">          type=<span class="string">"text"</span></span><br><span class="line">          value=&#123;query&#125;</span><br><span class="line">          onChange=&#123;<span class="keyword">this</span>.onInputChange&#125;</span><br><span class="line">          &#123;...sharedProps&#125;</span><br><span class="line">          &#123;...inputProps&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &#123;isOpen &amp;&amp; (</span><br><span class="line">          &lt;List &#123;...sharedProps&#125; &#123;...listProps&#125;&gt;</span><br><span class="line">            &#123;options.map(<span class="function"><span class="params">option</span> =&gt;</span> &#123;</span><br><span class="line">              &lt;Option</span><br><span class="line">                onClick=&#123;<span class="keyword">this</span>.onOptionClick.bind(<span class="keyword">this</span>, option)&#125;</span><br><span class="line">                $option=&#123;option&#125;</span><br><span class="line">                &#123;...sharedProps&#125;</span><br><span class="line">                &#123;...optionProps&#125;</span><br><span class="line">              &gt;</span><br><span class="line">                &#123;option.label&#125;</span><br><span class="line">              &lt;<span class="regexp">/Option&gt;</span></span><br><span class="line"><span class="regexp">            &#125;)&#125;</span></span><br><span class="line"><span class="regexp">          &lt;/</span>List&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      &lt;<span class="regexp">/Root&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line">// https://gist.github.com/schnerd/30c1415b7621d0e71352aa0c0184f175#file-overrides-example-internal-js</span><br></pre></td></tr></table></figure><p>请注意，render 方法不包含像<code>&lt;div&gt;</code>这样的原生 DOM。我们从相邻的文件中导入默认的子组件。在这个文件中我们使用 CSS-in-JS 库来创建封装所有默认样式的组件。如果组件传递了<code>overrides</code>，则它优先于这些默认值。</p><p><code>getComponents</code>只是一个很简单的辅助函数，我们使用它来解压需要覆盖的参数并将它们与组件的默认样式合并到一处。很多方法可以实现这，下面是个简短的示例：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComponents</span>(<span class="params">defaultComponents, overrides</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.keys(defaultComponents).reduce(<span class="function">(<span class="params">acc, name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> override = overrides[name] || &#123;&#125;;</span><br><span class="line">    acc[name] = &#123;</span><br><span class="line">      component: override.component || defaultComponents[name],</span><br><span class="line">      props: &#123; <span class="attr">$style</span>: override.style, ...override.props &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">  &#125;, &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://gist.github.com/schnerd/c6753b941954f96ec16fea2ce47e74d8#file-overrides-example-getcomponents-js</span></span><br></pre></td></tr></table></figure><p>这个函数指定了 style 覆盖到为名为<code>$style</code>的 prop，并将其与其他的覆盖 prop 合并到一起——这主要是因为我们使用 CSS-in-JS 实现了查找<code>$style</code>并将其与默认样式深度合并。</p><p>每个子组件也接受<code>sharedProps</code>，它可以用于动态更改样式或渲染——例如，在出现错误时将 border-color 设置为 red。我们将这些 props 添加<code>$</code>前缀作为一个命名规则的约定，以表明这些是特殊的 props，不应该传递给底层的 DOM 元素。</p><h1 id="权衡-amp-陷阱"><a href="#权衡-amp-陷阱" class="headerlink" title="权衡 &amp; 陷阱"></a>权衡 &amp; 陷阱</h1><p>与大多数设计模式一样，在使用覆盖模式的时候也需要全更一些因素。</p><h2 id="刚性"><a href="#刚性" class="headerlink" title="刚性"></a>刚性</h2><p>因为每个内部元素都有一个标识符并作为覆盖的目标公开，所以更改 DOM 结构可能会导致超出预期的变化出现频次高于正常情况。对于 CSS 的变化来说也会有同样的问题——改变元素样式从<code>display: flex</code>到<code>display: block</code>理论上同样是个重大的改变，如果使用者觉得这是一个 flexbox 的内部并这样覆盖其中一个子元素的样式。通常都整齐封装的组件实际上可能会使下游受到影响从而出现问题。</p><p>所以的这些都意味着你可能需要更加小心地改变组件的 DOM 结构或者样式，并且不要害怕当一个主要版本的修改受到质疑的时候。</p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>现在你的内部元素是公共 API 的一部分，你可能会希望编写一个文档去描述每个元素以及它可以传入的 porps。包括使用一些简单的图表来描述它的 DOM 结构，以及它们的标识。</p><p>使用 TypeScripts 或 Flow 这类可以静态类型检查的方法在这里会是一个很棒的方案，因为它将使开发人员清楚地知道每个组件可以接受哪些 props，以及你覆盖的方式是否兼容。</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>想象一下，你正在使用<code>Button</code>组件来构建一个可复用的<code>Pagination</code>组件来完成分页功能，我们如何将<code>Pagination</code>组件内的<code>Button</code>组件覆盖方法暴露出来呢？如果有多个按钮（例如：首页、上一页、下一页、尾页等），使用者可能想要以不同的方式去设置该怎么办？我们对于如何处理这一类问题有些<a href="https://github.com/uber-web/baseui/issues/375" target="_blank" rel="noopener">想法</a>，但是这并不能解决根本，在最终方案出现之前还需要反复地去实验。</p><h2 id="复杂性"><a href="#复杂性" class="headerlink" title="复杂性"></a>复杂性</h2><p>支持组件的复用会提升其复杂性，并且破事你更加批判性的考虑使用者如何覆盖你的内部组件。如果你只是构建一个将在自己的应用程序中重复使用几次的组件，那么这种复杂性的增加可能并不值得。但是如果你正在构建一个可供数百名工程师使用的可复用的组件库，那么为了这些使用者的便利而牺牲简洁的写法就非常有意义了。对于我们来说这是一个简单的决定，因为那工程师使用组件时那些有趣的用法一直令我们印象深刻。</p><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p>现在来说，覆盖模式只是一种模式，并没有刻意安装的库或者包，但是如果你想看看我们在自己的组件库中如何使用这个模式，你可以在<a href="https://github.com/uber-web/baseui" target="_blank" rel="noopener">github</a>上浏览我们的项目。</p><p>希望你发现这个模式刻意很有用，或者至少有一些关于如何提高你的 React 组件复用率的新想法！</p><p>—</p><p><em>有疑问或想法吗？你可以发表评论或者在推特上找到我哦：@dschnr</em></p><p>原文链接: <a href="https://medium.com/@dschnr/better-reusable-react-components-with-the-overrides-pattern-9eca2339f646" target="_blank" rel="noopener">https://medium.com/@dschnr/better-reusable-react-components-with-the-overrides-pattern-9eca2339f646</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> React </tag>
            
            <tag> Component </tag>
            
            <tag> Web </tag>
            
            <tag> CSS-In-JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么选择Hook而非……?</title>
      <link href="/Why-Isn%E2%80%99t-X-a-Hook/"/>
      <url>/Why-Isn%E2%80%99t-X-a-Hook/</url>
      
        <content type="html"><![CDATA[<p>自从第一个关于<a href="https://reactjs.org/hooks" target="_blank" rel="noopener">React Hooks</a>的 alpha 版本发布以来，有一个问题不断出现在讨论中：“为什么是 Hook 而非 _&lt;一些其他的 API&gt;_ ？”</p><p>提示一下，以下的这些就<em>是</em>Hooks：</p><ul><li><a href="https://reactjs.org/docs/hooks-reference.html#usestate" target="_blank" rel="noopener"><code>useState()</code></a> 用于声明一个状态变量。</li><li><a href="https://reactjs.org/docs/hooks-reference.html#useeffect" target="_blank" rel="noopener"><code>useEffect()</code></a> 用于声明一个补充规则(side effect)。</li><li><a href="https://reactjs.org/docs/hooks-reference.html#usecontext" target="_blank" rel="noopener"><code>useContext()</code></a> 用于读取一些上下文的内容。</li></ul><a id="more"></a><p>但是仍有一些其他的 API，例如<code>React.memo()</code>和<code>&lt;Context.Provider&gt;</code>，它们<em>不是</em>Hooks。通常提出的 Hook 版本会建议是<em>noncompositional</em>或者<em>antimodular</em>。本文将帮助你了解原因。</p><p><strong>提示：这篇文章对那些对 API 讨论感兴趣的人来说是一个深刻的话题，你不需要考虑使用 React 来提升效率！</strong></p><hr><p>我们希望 React API 保留两个重要属性：</p><ol><li><strong>构成 Composition:</strong> <a href="https://reactjs.org/docs/hooks-custom.html" target="_blank" rel="noopener">定制 Hooks</a>很大程度上是我们对 Hooks API 感到兴奋的原因。我们希望大家可以频繁的构建自己的 Hooks，并且我们需要保证不同人写的 Hooks<a href="https://overreacted.io/why-do-hooks-rely-on-call-order/#flaw-4-the-diamond-problem" target="_blank" rel="noopener">不会发生冲突</a>。（我们大概会被编写清爽且不会相互破坏的组件这样的体验宠坏吧！）</li><li><strong>调试 Debugging:</strong> 我们希望随着程序的增长，Bugs<a href="/archives/algorithm/1549245751.html">很容易找到</a>。React 的最佳特征之一就是——如果你看到呈现出了任何错误，都能够通过结构树找到那个组件的 prop 或 state 导致的错误。</li></ol><p>这两个约束放在一起可以告诉我们什么可以或<em>不可以</em>使用 Hook。让我们看几个例子。</p><hr><h2 id="使用-Hook：useState"><a href="#使用-Hook：useState" class="headerlink" title="使用 Hook：useState()"></a>使用 Hook：<code>useState()</code></h2><h3 id="构成-Composition"><a href="#构成-Composition" class="headerlink" title="构成 Composition"></a>构成 Composition</h3><p>每个调用<code>useState()</code>的多个自定义 Hook 都不会冲突：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMyCustomHook1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// What happens here, stays here.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMyCustomHook2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// What happens here, stays here.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  useMyCustomHook1();</span><br><span class="line">  useMyCustomHook2();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加一个新的无条件<code>useState()</code>调用总是安全的。你不需要了解组件用于声明新状态变量的其他 Hook，也不能通过更新其中一个来破坏其他的状态变量。</p><p><strong>结论：</strong> ✅ <code>useState()</code>不会使自定义 Hook 易碎。</p><h3 id="调试-Debugging"><a href="#调试-Debugging" class="headerlink" title="调试 Debugging"></a>调试 Debugging</h3><p>钩子会很有用，因为你可以用过它<em>传递</em>值：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useWindowWidth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [width, setWidth] = useState(<span class="built_in">window</span>.innerWidth);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useTheme</span>(<span class="params">isMobile</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Comment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> width = useWindowWidth();</span><br><span class="line">  <span class="keyword">const</span> isMobile = width &lt; MOBILE_VIEWPORT;</span><br><span class="line">  <span class="keyword">const</span> theme = useTheme(isMobile);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">section</span> <span class="attr">className</span>=<span class="string">&#123;theme.comment&#125;</span>&gt;</span>&#123;/* ... */&#125;<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果我们犯错了呢？该如何调试？</p><p>假设我们从<code>theme.comment</code>获得的 CSS 类是错误的，我们该如何调试？我们可以在组件的主体中设置断点或几个日志输出。</p><p>也许我们会看到<code>theme</code>错误但是<code>width</code>和<code>isMobile</code>是正确的。这会告诉我们问题是<code>useTheme()</code>中的。或者也许我们会看到<code>width</code>本身就是错的，那我们就应该查看<code>useWindowWidth()</code>。</p><p><strong>单独查看中间值会告诉我们顶层的那些 Hook 包含 Bug。</strong>我们不需要查看他们<em>所有的</em>实现。</p><p>然后我们可以“放大”有 Bug 的部分并尝试复现。</p><p>随着自定义 Hook 嵌套的深度增加，这会变得更加重要。想象我们有 3 个级别的自定义 Hook 嵌套，每个级别使用 3 个不同的自定义 Hooks。寻找<strong>3 处</strong>与潜在检查<strong>3 + 3×3 + 3×3×3 = 39 处</strong>之间的<a href="/archives/algorithm/1549245751.html">差异</a>是巨大的。幸运的是，<code>useState()</code>不能神奇的“影响”其他钩子或组件，它返回的错误值会在它后面留下一条痕迹，就像任何变量一样。🐛</p><p><strong>结论：</strong> ✅ <code>useState()</code>不会遮掩我们代码中的因果关系，我们可以直接通过痕迹追踪到 Bug。</p><hr><h2 id="不应使用-Hook：useBailout"><a href="#不应使用-Hook：useBailout" class="headerlink" title="不应使用 Hook：useBailout()"></a>不应使用 Hook：<code>useBailout()</code></h2><p>作为优化，使用 Hooks 的组件可以避免重新渲染。</p><p>一种方法是将整个组件周围方式一个<a href="https://reactjs.org/blog/2018/10/23/react-v-16-6.html#reactmemo" target="_blank" rel="noopener"><code>React.memo()</code></a>包装器。如果 props 与我们在上一次渲染的过程中的 props 非常相等，他就会失去重新渲染的效果，这很类似<code>PureComponent</code>类。</p><p><code>React.memo()</code>接受一个组件并返回一个组件：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Button</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(Button);</span><br></pre></td></tr></table></figure><p><strong>但是为什么它不仅是个 Hook?</strong></p><p>无论你将它成为<code>useShouldComponentUpdate()</code>，<code>usePure()</code>，<code>useSkipRender()</code>或<code>useBailout()</code>，这个体验往往看起来是这样的：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Button</span>(<span class="params">&#123; color &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ⚠️ Not a real API</span></span><br><span class="line">  useBailout(<span class="function"><span class="params">prevColor</span> =&gt;</span> prevColor !== color, color);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&#123;</span>"<span class="attr">button-</span>" + <span class="attr">color</span>&#125;&gt;</span>OK<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一些变化（eg：一个简单的<code>usePure()</code>标记）但是在广泛的笔划中他们具有相同的缺陷。</p><h3 id="构成-Composition-1"><a href="#构成-Composition-1" class="headerlink" title="构成 Composition"></a>构成 Composition</h3><p>假设我们尝试将<code>useBailout()</code>放在两个自定义 Hooks 中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFriendStatus</span>(<span class="params">friendID</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚠️ Not a real API  useBailout(prevIsOnline =&gt; prevIsOnline !== isOnline, isOnline);</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handleStatusChange = <span class="function"><span class="params">status</span> =&gt;</span> setIsOnline(status.isOnline);</span><br><span class="line">    ChatAPI.subscribe(friendID, handleStatusChange);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> ChatAPI.unsubscribe(friendID, handleStatusChange);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isOnline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useWindowWidth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [width, setWidth] = useState(<span class="built_in">window</span>.innerWidth);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ⚠️ Not a real API  useBailout(prevWidth =&gt; prevWidth !== width, width);</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handleResize = <span class="function"><span class="params">()</span> =&gt;</span> setWidth(<span class="built_in">window</span>.innerWidth);</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>, handleResize);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">window</span>.removeEventListener(<span class="string">"resize"</span>, handleResize);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> width;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在如果你在同一个组件使用它们会发生什么？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ChatThread</span>(<span class="params">&#123; friendID, isTyping &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> width = useWindowWidth();</span><br><span class="line">  <span class="keyword">const</span> isOnline = useFriendStatus(friendID);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ChatLayout width=&#123;width&#125;&gt;</span><br><span class="line">      &lt;FriendStatus isOnline=&#123;isOnline&#125; /&gt;</span><br><span class="line">      &#123;isTyping &amp;&amp; <span class="string">"Typing..."</span>&#125;</span><br><span class="line">    &lt;<span class="regexp">/ChatLayout&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>什么时候重新渲染？</p><p>如果每个<code>useBailout()</code>调用都有权跳过更新，那么来自<code>useWindowWidth()</code>的更新将被<code>useFriendStatus()</code>阻塞，反之亦然。<strong>这些 Hook 会相互破坏。</strong></p><p>但是，如果<code>useBailout()</code>尽在单个组件内的<em>所有</em>调用“同意”阻止更新时才能使用，那么我们的<code>ChatThread</code>将无法更新<code>isTyping</code>prop 的更改。</p><p>更糟糕的是，使用这些语义<strong>任何新添加到 ChatThread 的 Hook 如果没有调用 useBailout()将会损坏</strong>。否则，他们不能“反对”使用<code>useWindowWidth()</code>和 <code>useFriendStatus()</code>救助。</p><p><strong>结论：</strong> 🔴 <code>useBailout()</code>打破了构建方式，将其添加到 Hook 会破坏其他 Hook 的状态更新。我们希望 API 可以具有<a href="https://overreacted.io/optimized-for-change/" target="_blank" rel="noopener">防碎性</a>，而这种行为却背道而驰。</p><h3 id="调试-Debugging-1"><a href="#调试-Debugging-1" class="headerlink" title="调试 Debugging"></a>调试 Debugging</h3><p>像<code>useBailout()</code>这样的 Hook 如何影响调试？</p><p>我们将使用相同的示例：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ChatThread</span>(<span class="params">&#123; friendID, isTyping &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> width = useWindowWidth();</span><br><span class="line">  <span class="keyword">const</span> isOnline = useFriendStatus(friendID);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ChatLayout width=&#123;width&#125;&gt;</span><br><span class="line">      &lt;FriendStatus isOnline=&#123;isOnline&#125; /&gt;</span><br><span class="line">      &#123;isTyping &amp;&amp; <span class="string">"Typing..."</span>&#125;</span><br><span class="line">    &lt;<span class="regexp">/ChatLayout&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>当我们期望<code>Typing...</code>标签不会出现，即便在上层的 prop 正在发生变化。我们该怎么调试？</p><p><strong>通常，在 React 中你自信可以通过查找来给出确切的回答。</strong>如果<code>ChatThread</code>没能得到一个新的<code>isTyping</code>值，我们可以打开呈现<code>&lt;ChatThread isTyping={myVar} /&gt;</code>的组件并检查<code>myVar</code>，以此类推。在其中一个级别，我们要么找到一个错误的<code>shouldComponentUpdate()</code>救助，要么传递不正确的<code>isTyping</code>值。一看链中的每个组件通常足以追寻到问题的根源。</p><p>但是如果这个<code>useBailout()</code>Hook 是真的，你永远也不会知道更新被跳过的原因，知道你检查我们的<code>ChatThread</code>及其所有者链中的组件使用的<em>每个自定义 Hook</em>（的深度）。由于每个父组件也可以使用自定义 Hook，因此<a href="/archives/algorithm/1549245751.html">拓展</a>非常糟糕。</p><p>就像你在抽屉里寻找一把螺丝刀一样，每个抽绎都有一堆较小的抽屉柜，你不知道兔子洞有多深。</p><p><strong>结论：</strong> 🔴 <code>useBailout()</code>Hook 不仅打破了构建，更大大增加了调试步骤和求助所需的认知门槛——在某些情况下，呈指数式增加。</p><hr><p>我们只看到了一个真正的 Hook，<code>useState()</code>，还有一个关于<em>不该使用</em>Hook 的常规建议——<code>useBailout()</code>。我们通过构建和调试的棱镜对他们进行了比较，讨论了它们中工作与否的原因。</p><p>虽然没有<code>memo()</code>和<code>shouldComponentUpdate()</code>的“Hook 版本”，但 React<em>会</em>提供一个 Hook 调用<a href="https://reactjs.org/docs/hooks-reference.html#usememo" target="_blank" rel="noopener"><code>useMemo()</code></a>的方法。它有类似的用途，但它语义不同，并不会遭遇上述陷阱。</p><p><code>useBailout()</code>只是一个不该使用 Hook 工作的例子，还有很多类似的——例如：<code>useProvider()</code>，<code>useCatch()</code>或<code>useSuspense()</code>。</p><p>你明白为什么吗？</p><p><em>（小声：组成…调试…）</em></p><p><a href="https://mobile.twitter.com/search?q=https%3A%2F%2Foverreacted.io%2Fwhy-isnt-x-a-hook%2F" target="_blank" rel="noopener">Discuss on Twitter</a> • <a href="https://github.com/gaearon/overreacted.io/edit/master/src/pages/why-isnt-x-a-hook/index.md" target="_blank" rel="noopener">Edit on GitHub</a></p><p>原文链接： <a href="https://overreacted.io/why-isnt-x-a-hook/" target="_blank" rel="noopener">Why Isn’t X a Hook?</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用懒加载和Suspense提高React性能</title>
      <link href="/improve-react-performance-using-lazy-loading-and-suspense/"/>
      <url>/improve-react-performance-using-lazy-loading-and-suspense/</url>
      
        <content type="html"><![CDATA[<p>Lazy loading💤 已经成为被广泛应用于加载提速的优化技术之一。延迟加载的前景有助于将某些 web app 出现程序性能问题的风险降至最低〽。</p><p>在本文中，我们将研究如何使用 Lazy loading💤 来优化 React 应用程序中的加载时间。</p><a id="more"></a><h1 id="什么是-Lazy-Loading💤？"><a href="#什么是-Lazy-Loading💤？" class="headerlink" title="什么是 Lazy Loading💤？"></a>什么是 Lazy Loading💤？</h1><p>懒加载是一种优化技巧 💫 我们通过延迟对象(图片 🎦, 视频 🎬, 网页 🌎, 音乐 🎶, 文档 📋) 加载直到他们被使用。</p><p>当用户打开一个页面，所有的内容将一次性下载下来。大多数内容可能永远也不会发生作用或者被用户看见。所以为什么要浪费宝贵的资源和带宽呢？</p><p>为了提高我们网站的响应时间，我们选择延迟加载一些应用程序中的非关键部分。当用户需要访问这些部分的时候，再加载这些资源。</p><h1 id="SSR-CSR-和-React"><a href="#SSR-CSR-和-React" class="headerlink" title="SSR, CSR 和 React"></a>SSR, CSR 和 React</h1><p>我们有 SSR(server-side rendered / 服务端呈现)应用程序和 CSR(Client side rendered / 客户端呈现)应用程序。</p><p>SSR 是使用.HTML 构建的优秀传统页面，可以选择配合 ASP.NEt 或是 PHP 等来使用。每个连接都有一个不同的.HTML 文件需要加载。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">web-app&#x2F;</span><br><span class="line"> - index.html</span><br><span class="line"> - about.html</span><br><span class="line"> - faq.html</span><br><span class="line"> - careers.html</span><br></pre></td></tr></table></figure><p>每个页面都要记载不同的 HTML 文件。</p><p>随着 JS 框架的出现，网页被浑河成为一个单独的 js 并一次性加载完成。在浏览器中执行时，浏览器 DOM 生成所请求的页面。</p><p>在 React 中，假设我们有这样的应用程序：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; (</span><br><span class="line">  &lt;Switch&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/about"</span> component=&#123;About&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/faq"</span> component=&#123;FAQ&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/careers"</span> component=&#123;Careers&#125; /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ about.js</span></span><br><span class="line"><span class="regexp">class About extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return &lt;div&gt;About page&lt;/</span>div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// faq.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FAQ</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>FAQ page<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// careers.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Careers</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Careers page<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在打包时，webpack 将所有的 js 文件打包成一个<code>index.js</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">react-app&#x2F;</span><br><span class="line"> dist&#x2F;</span><br><span class="line">  - index.html</span><br><span class="line">  - index.js</span><br></pre></td></tr></table></figure><p>所有的文件包括 index.js, about.js, faq.js, careers.js 都捆绑在一个文件中。现在，当我们加载 index.html 文件时，它会沿着负载很重的 index.js 被加载。现在，解析 index.js 和渲染中的所有代码所花费的时间 ⏰ 将是漫长的等待。如果每个文件执行所花费的时间如下：</p><ul><li>index.js 2ms</li><li>about.js 10ms</li><li>faq.js 5ms</li><li>careers.js 9ms</li></ul><p>打包后:</p><ul><li>index.js 26ms</li></ul><p>所以我们会等待<code>26ms</code>!!但是如果我们可以将 React 中的文件分开并按需加载它们，我们将在<code>2ms</code>内看到程序加载并相应。</p><p>因此，我们可以将包拆分成多个小块并在运行时动态加载，而非一次性下载整个代码。</p><p>已经有很多技术用于支持将 React apps 做代码拆分了。我们在下一节中有更多的讲解。</p><h1 id="⏬Dynamic-Import"><a href="#⏬Dynamic-Import" class="headerlink" title="⏬Dynamic Import"></a>⏬Dynamic Import</h1><p>为了将我们的 JS 应用做代码分割，将引入 import()函数，目前它仍是一个提案，尚未成为 JavaScript 标准的一部分。</p><p>此功能可以将我们的应用程序拆分成为块并按需加载它们。</p><p>The import()接受一个字符串作为参数。字符串是将要加载的 js 文件的路径。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">"./js_file_to_load.js"</span>);</span><br></pre></td></tr></table></figure><p>当 webpack 遇到这种情况时，它就会将文件分别捆绑在不同路径中。</p><h1 id="💤React-lazy"><a href="#💤React-lazy" class="headerlink" title="💤React.lazy()"></a>💤React.lazy()</h1><p>React.lazy 是 Reactv16.6 发布时添加到 React 的新特性，它为我们的 React 组件提供了一种简单直接的方法来完成延迟加载和代码分割。</p><blockquote><p><em>React.lazy 函数允许你将动态导入的组件按常规呈现。 —</em> <a href="http://reactjs.org/docs/code-splitting.html" target="_blank" rel="noopener"><em>React blog</em></a></p></blockquote><p>React.lazy 可以轻松创建和渲染组件并动态的导入它们。React.lazy 将函数作为参数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">React.lazy(cb);</span><br></pre></td></tr></table></figure><p>这个回调函数必须使用动态<code>import()</code>语法来加载组件的文件：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyComponent.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>MyComponent<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> MyComponent = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">"./MyComponent.js"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AppComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;MyComponent /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ or</span></span><br><span class="line"><span class="regexp">function cb() &#123;</span></span><br><span class="line"><span class="regexp">  return import("./</span>MyComponent.js<span class="string">");</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">const MyComponent = React.lazy(cb);</span></span><br><span class="line"><span class="string">function AppComponent() &#123;</span></span><br><span class="line"><span class="string">  return (</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;MyComponent /&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  );</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>React.lazy 的回调函数会通过<code>import()</code>的调用返回一个 Promise 对象。如果模块加载成功则 Promise 对象 resolve，如果由于网络故障，路径解析错误，找不到文件等原因加载模块时出错，则 Promise 对象 reject。</p><p>当 webpack 遍历我们的代码进行编译打包的时候，它会在遇到<code>React.lazy()</code>和<code>import()</code>时，创建一个单独的捆绑包。我们的应用程序将如下显示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">react-app</span><br><span class="line"> dist&#x2F;</span><br><span class="line">  - index.html</span><br><span class="line">  - main.b1234.js (contains Appcomponent and bootstrap code)</span><br><span class="line">  - mycomponent.bc4567.js (contains MyComponent)</span><br><span class="line">&#x2F;** index.html **&#x2F;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;main.b1234.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br></pre></td></tr></table></figure><p>现在，我们的应用程序分为多个捆绑包。当 AppComponent 被渲染的时候，mycomponent.bc4567.js 文件将被加载并在 DOM 上的显示包含 MyComponent。</p><blockquote><p>译者注：目前 React.lazy 还不支持服务端使用，目前官方推荐使用<a href="https://github.com/smooth-code/loadable-components" target="_blank" rel="noopener">Loadable Components</a>，它有很棒的<a href="https://github.com/smooth-code/loadable-components/blob/master/packages/server/README.md" target="_blank" rel="noopener">服务端渲染指南</a>。或者你也可以尝试使用<a href="https://github.com/jamiebuilds/react-loadable" target="_blank" rel="noopener">react-loadable</a>，这是一个小型库，用于加载具有动态导入组件的高阶组件，使用它你可以完成错误超时状态配置、避免加载闪烁、加载多个资源、预加载、服务端渲染等功能。</p></blockquote><h1 id="🚦React-Suspense"><a href="#🚦React-Suspense" class="headerlink" title="🚦React Suspense"></a>🚦React Suspense</h1><p>现在，当文件 mycomponent.bc4567.js 被加载时会发生什么，从加载到 MyComponent 被渲染必定会有一个时间延迟。用户会看到什么呢？</p><p>显然，你的应用程序似乎会冻结一段时间。这将是个糟糕的用户体验。我们需要让用户指导正在发生或加载的事情。为了做到这一点，添加了与 React.lazy 相关联的新特性，他就是<code>Suspense</code>组件。</p><p>Suspense 组件用于包装延迟组件，以在加载惰性组件时显示一些备用信息。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Lazycomponent = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./lazy.component.js"</span>));</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AppComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Suspense fallback=&#123;&lt;div&gt;loading ...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &lt;LazyComponent /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正在延迟加载的组件将插入到 Suspense 组件的标记内。向用户展示的内容告诉他们正在进行的内容放在 Suspense 组件标记的 fallback prop 中。</p><p>组件也可以用于 fallback prop：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LoadingIndicator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>loading ...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AppComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Suspense fallback=&#123;&lt;LoadingIndicator /&gt;&#125;&gt;</span><br><span class="line">        &lt;LazyComponent /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以再 Suspense 标记中放置多个惰性组件。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Lazycomponent1 = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./lazy.component1.js"</span>));</span><br><span class="line"><span class="keyword">const</span> Lazycomponent2 = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./lazy.component2.js"</span>));</span><br><span class="line"><span class="keyword">const</span> Lazycomponent3 = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./lazy.component3.js"</span>));</span><br><span class="line"><span class="keyword">const</span> Lazycomponent4 = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./lazy.component4.js"</span>));</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AppComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;div&gt;loading ...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;LazyComponent1 /</span>&gt;</span><br><span class="line">      &lt;LazyComponent2 /&gt;</span><br><span class="line">      &lt;LazyComponent3 /&gt;</span><br><span class="line">      &lt;LazyComponent4 /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="👮-捕获加载错误"><a href="#👮-捕获加载错误" class="headerlink" title="👮 捕获加载错误"></a>👮 捕获加载错误</h1><p>在我们使用 React.lazy 时，我们提到 import()函数会返回一个 Promise 对象，可能会由于某些原因在 reject 中返回加载错误：</p><ul><li>网络故障</li><li>文件未找到</li><li>文件路径错误</li></ul><p>现在，我们不希望我们的应用程序因为这些悲惨地发生错误。我们希望荣耀的有尊严地错误。为了在失败时展现出良好的用户体验，我们将在惰性组件上放置一个错误边界。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Lazycomponent1 = React.lazy(<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">import</span>(<span class="string">'./lazy.component1.js'</span>))</span><br><span class="line"><span class="keyword">const</span> Lazycomponent2 = React.lazy(<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">import</span>(<span class="string">'./lazy.component2.js'</span>))</span><br><span class="line"><span class="keyword">const</span> Lazycomponent3 = React.lazy(<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">import</span>(<span class="string">'./lazy.component3.js'</span>))</span><br><span class="line"><span class="keyword">const</span> Lazycomponent4 = React.lazy(<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">import</span>(<span class="string">'./lazy.component4.js'</span>))</span><br><span class="line"><span class="keyword">import</span> ErrorBoundary <span class="keyword">from</span> <span class="string">'./error.boundary.js'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AppComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;ErrorBoundary&gt;</span><br><span class="line">            &lt;Suspense fallback=&#123;&lt;div&gt;loading ...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">                &lt;LazyComponent1 /</span>&gt;</span><br><span class="line">                &lt;LazyComponent2 /&gt;</span><br><span class="line">                &lt;LazyComponent3 /&gt;</span><br><span class="line">                &lt;LazyComponent4 /&gt;</span><br><span class="line">            &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ErrorBoundary/</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="✂-基于路由（route-based）的代码拆分"><a href="#✂-基于路由（route-based）的代码拆分" class="headerlink" title="✂ 基于路由（route-based）的代码拆分"></a>✂ 基于路由（route-based）的代码拆分</h1><p>如何拆分代码是个棘手的问题。有两种最常用的方法是基于路由（<code>route-based</code>）拆分和基于组件（<code>component-based</code>）拆分。</p><blockquote><p><em>基于路由的代码拆分将应用程序分解为每个路由对应的块。</em></p></blockquote><p>基于路由的代码拆分是将代码拆分为与应用程序路由相关的包。在 SPA（single page web application，单页面应用）中，所有的 route 或 path 都是在 DOM 上完成的。当你点击超链接时，DOM 捕获事件并通过 SPA 框架运行它，在 DOM 中将销毁当前视图当组件附加请求路径创建并呈现的时候。</p><p>所有的这些组件都捆绑在一个文件中被传递。现在，通过基于路由的分块，我们可以将代码分成块。每个块只与特定路由有关。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index,js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;Switch&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/about"</span> component=&#123;About&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/faq"</span> component=&#123;FAQ&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/careers"</span> component=&#123;Careers&#125; /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>当我们使用基于路由的方法拆分次应用程序时，我们将看到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">react-app&#x2F;</span><br><span class="line"> - index.html</span><br><span class="line"> - index.bacd0123.js (contains App)</span><br><span class="line"> - about.1234.js (contains About component)</span><br><span class="line"> - faq.5678.js (contains FAQ component)</span><br><span class="line"> - careers.9012.js (contains Careers component)</span><br><span class="line">&#x2F;** index.html **&#x2F;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;index.bacd0123.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br></pre></td></tr></table></figure><p>当我们加载我们的 app 路径<code>/</code>时，应用仅呈现该页面。现在，如果我们导航到<code>/faq</code>，那么 faq.5678.js 文件将通过网络获取并加载，包括组件 FAQ 将被渲染。</p><p>因此，我们将看到的代码是根据我们定义的路由进行拆分的。这并没有 100%优化我们的应用程序，有一些缺点，但至少我们从我们的应用程序中减少了相当大的延迟时间。这个与代码分割相关的另一种优化技术被称为 prefetching，但这将在另一篇文章中。</p><h1 id="🔪-基于组件（Component-based）的代码拆分"><a href="#🔪-基于组件（Component-based）的代码拆分" class="headerlink" title="🔪 基于组件（Component-based）的代码拆分"></a>🔪 基于组件（Component-based）的代码拆分</h1><p>在 Web 应用程序中，有如下许多小部件：</p><ul><li>模型（modals）</li><li>tabs</li><li>折叠面板（accordion）</li><li>进度条（progressbars）</li><li>侧边菜单（sidenav）</li><li>footer</li><li>header</li><li>面板（panel）</li><li>等等</li></ul><p>这些小部件或组件为我们的用户提供了丰富的体验。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ModalComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">modal</span>&gt;</span>Modal shows!!!<span class="tag">&lt;/<span class="name">modal</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mycomponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.display = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;ModalComponent display=&#123;<span class="keyword">this</span>.dispaly&#125; /&gt;</span><br><span class="line">    &lt;button onclick=&#123;(<span class="keyword">this</span>.display = <span class="literal">true</span>)&#125;&gt;Open Modal&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button onclick=&#123;(this.display = false)&#125;&gt;Close Modal&lt;/</span>button&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">react - app /</span> dist / -index.html - index.js;</span><br></pre></td></tr></table></figure><p>尽管他们提供了很多好东西，但他们也会导致我们的应用程序性能不佳。大多数组件隐藏，指导用户完成相关操作时才会显现。在用户滚动到底部或按侧边按钮之前，你不会看到 footer 和 sidenev。大多数情况下，用户甚至可能不会与其中任意一个进行交互。</p><p>所有这些都加载到我们的应用程序中，并在加载时构成时间延迟。当用户试图与他们交互时，加载并展现他们不会更好么？</p><p>在这种情况下，基于组件的拆分有很大的帮助。所有的小部件或组件都将单独打包。每个捆绑包上一个小部件，Web 开发人员需要采用捆绑技术，但更重要的是按需加载这些部件。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// modalcomponent.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ModalComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">modal</span>&gt;</span>Modal shows!!!<span class="tag">&lt;/<span class="name">modal</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mycomponent.js</span></span><br><span class="line"><span class="keyword">const</span> ModalComponent = React.lazy(<span class="keyword">import</span>(<span class="string">'./modalcomponent.js'</span>))</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.display = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;Suspense fallback=&#123;&lt;div&gt;loading ...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">            &lt;ModalComponent display=&#123;this.display&#125; /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onclick=&#123;this.display = true&#125;&gt;Open Modal&lt;/</span>button&gt;</span><br><span class="line">        &lt;button onclick=&#123;<span class="keyword">this</span>.display = <span class="literal">false</span>&#125;&gt;Close Modal&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> MyComponent = React.lazy(<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">import</span>(<span class="string">'./mycomponent.js'</span>))</span><br><span class="line"><span class="keyword">import</span> ErrorBoundary <span class="keyword">from</span> <span class="string">'./error.boundary.js'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AppComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;ErrorBoundary&gt;</span><br><span class="line">            &lt;Suspense fallback=&#123;&lt;div&gt;loading ...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">                &lt;MyComponent /</span>&gt;</span><br><span class="line">            &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ErrorBoundary/</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">react-app/</span></span><br><span class="line"> dist/</span><br><span class="line">  - index.html</span><br><span class="line">  - index.js</span><br><span class="line">  - mycomponent.js</span><br><span class="line">  - modalcomponent.js (contains the ModalComponent)</span><br></pre></td></tr></table></figure><p>我们看到最初没有加载 ModalComponent，他在用户单击<code>Open Modal</code>按钮时，才会触发加载。</p><h1 id="🔚-结论"><a href="#🔚-结论" class="headerlink" title="🔚 结论"></a>🔚 结论</h1><p>在这篇文章中，我们看到了如何通过代码分割和延迟加载来改进 🚀React 应用程序的性能。首先我们介绍了动态 import()函数；然后，我们看到了还可以使用不同的技术方案，如 React 的新特性 💤<code>React.lazy()</code>和 🚦<code>Suspense</code>。</p><p>通过我们在这篇文章中学到的这些不同的优化技巧，我们可以生成高性能高质量的 React 应用。</p><p>如果你对此有任何问题，或者我有任何遗漏，请随时在下面发表评论或向我询问任何问题！👏 你也可以在<a href="https://twitter.con/@ngarchangel" target="_blank" rel="noopener">Twitter</a>, <a href="https://facebook.com/philip.david.5011" target="_blank" rel="noopener">Facebook</a>和这里找到我。</p><p>蟹蟹 !!!💯</p><h1 id="💞Credits"><a href="#💞Credits" class="headerlink" title="💞Credits"></a>💞Credits</h1><ul><li><a href="https://gist.github.com/philipszdavido/reactjs.org/docs/code-splitting.html" target="_blank" rel="noopener">✅Reactjs Blog</a></li></ul><p>原文链接： <a href="https://blog.bitsrc.io/improve-react-performance-using-lazy-loading-and-suspense-933903171954" target="_blank" rel="noopener">Improve React Performance using Lazy Loading💤 and Suspense</a></p><p><a href="https://zakarycode.github.io/archives/front-end/frame/React/1546835543.html" target="_blank" rel="noopener">转载链接</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> React </tag>
            
            <tag> Performance </tag>
            
            <tag> Web Development </tag>
            
            <tag> Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 16.6 发布，一大波新功带你看未来的 React 开发方式</title>
      <link href="/React-16.6.*/"/>
      <url>/React-16.6.*/</url>
      
        <content type="html"><![CDATA[<p>最近（其实已经老久了，只是没跟上）<code>React</code> 官方发布了 16.6 版本，开放了一堆新的功能，而这其中的一些新功能，代表这未来的 React 开发方式，让我们来一起窥探未来吧。</p><a id="more"></a><h2 id="lazy"><a href="#lazy" class="headerlink" title="lazy"></a>lazy</h2><p>最让人期待的功能肯定就是 <code>lazy</code> 功能了，配合发布了一个 <code>Suspense</code> 组件，也就是最开始命名为 <code>Placeholder</code> 的组件，用来配合 <code>render</code> 方法内部的异步操作的，让我们先来看一下 <code>lazy</code> 的用法</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; lazy, Suspense &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">const</span> OtherComponent = lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./OtherComponent"</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;OtherComponent /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>做过 <code>code-splitting</code> 的同学能闻到熟悉的味道。以前我们要用第三方包或者自己处理异步过程，现在，<code>React</code> 原生支持啦，而且你可以把异步的过程直接扔到 <code>render</code> 方法里面，就跟写普通组件一样，而且可以方便得通过 <code>Suspense</code> 组件来提供 <code>fallback</code></p><p><strong>然而这并不仅仅 Suspense 的唯一用处，事实上这次 React 正式开放 Suspense 组件代表着所有异步的操作都可以在 render 方法里面做了，其实我很意外，我以为正式开放肯定要等到 17 版本</strong></p><p>那么异步操作还能做啥？如果同学们看过年初 Dan 在冰岛的分享，应该就知道，<code>Suspense</code> 能够让我们加载数据的操作变得异常简单。没看过的同学可以看<a href="https://link.juejin.im/?target=https%3A%2F%2Freactjs.org%2Fblog%2F2018%2F03%2F01%2Fsneak-peek-beyond-react-16.html">这里</a>，现在 npm 上也有一个包提供数据加载的功能了，<a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fsimple-cache-provider">simple-cache-provider</a>，但是现在还不要在正式环境使用他哦。</p><h2 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo"></a>React.memo</h2><p><code>ClassComponent</code> 可以通过继承类 <code>PureComponent</code> 或者实现 <code>shouldComponentUpdate</code> 来主动判断组件是否需要重新渲染，以此来提高性能，但是 <code>FunctionalComponent</code> 到目前为止没有类似的功能。</p><p>所以今天 <code>React</code> 发布了 <code>React.memo</code> 方法，来实现类似 <code>PureComponent</code> 的功能，即浅比较 <code>props</code> 是否有变化，如果没有变化，就不重新渲染当前组件</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FunctionalComponent = React.memo(<span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// only render if props change</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="static-contextType"><a href="#static-contextType" class="headerlink" title="static contextType"></a>static contextType</h2><p>在 <code>React16.3</code> 中提供了我们一个标准的用于替代老的 <code>context</code> 的 <code>API</code>，也就是 <code>React.createContext</code>，然后通过 <code>context.Provider</code> 和 <code>context.Consumer</code> 来传递值，这种方式消除了老的 <code>context API</code> 性能低下的问题，这个问题我在之前也有详细分析，感兴趣的同学可以看这里，而且老的 <code>API</code> 代码量很多，所以下个大版本 <code>React</code> 会移除老的 <code>API</code>。</p><p>但是在让生态插件升级到新的 <code>API</code> 的过程中，有人提出在 <code>ClassComponent</code> 中用新的 <code>API 很麻烦，所以</code>React<code>提供了一种在</code>ClassComponent<code>中使用新</code>API` 的方法</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> context = React.createContext(<span class="string">"defaultValue"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ProviderComp = <span class="function">(<span class="params">&#123; children &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;context.Provider value=<span class="string">"provider"</span>&gt;&#123;children&#125;&lt;<span class="regexp">/context.Provider&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class ConsumerComp extends Component &#123;</span></span><br><span class="line"><span class="regexp">  static contextType = context;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  componentDidMount() &#123;</span></span><br><span class="line"><span class="regexp">    console.log(this.context);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return &lt;p&gt;&#123;this.context&#125;&lt;/</span>p&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ProviderComp&gt;</span><br><span class="line">        &lt;ConsumerComp /&gt;</span><br><span class="line">      &lt;<span class="regexp">/ProviderComp&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这也是为了提高<code>React</code>的整体性能，移除老旧<code>API</code>做努力。</p><h2 id="static-getDerivedStateFromError"><a href="#static-getDerivedStateFromError" class="headerlink" title="static getDerivedStateFromError()"></a>static getDerivedStateFromError()</h2><p>在发布 <code>Error Boundaries</code> 的时候，<code>React</code> 提供了一个新的生命周期方法 <code>componentDidCatch</code>，在捕获到错误的时候会触发，你可以在里面修改 <code>state</code> 以显示错误提醒的 <code>UI</code>，或者将错误信息发送给服务端进行 <code>log</code> 用于后期分析。但是这里有个问题，就是在捕获到错误的瞬间，<code>React</code> 会在这次渲染周期中将这个组件渲染为 <code>null</code>，这就有可能导致他的父组件设置他上面的 <code>ref</code> 获得 <code>null</code> 而导致一些问题，所以现在提供了这个方法。</p><p>这个方法跟 <code>getDerivedStateFromProps</code> 类似，唯一的区别是他只有在出现错误的时候才触发，他相对于 <code>componentDidCatch</code> 的优势是在当前的渲染周期中就可以修改 <code>state</code>，以在当前渲染就可以出现错误的 <code>UI</code>，而不需要一个 <code>null</code> 的中间态。</p><p>而这个方法的出现，也意味着以后出现错误的时候，修改 <code>state</code> 应该放在这里去做，而后续收集错误信息之类的放到 <code>componentDidCatch</code> 里面。</p><h2 id="StrictMode-下的新提醒"><a href="#StrictMode-下的新提醒" class="headerlink" title="StrictMode 下的新提醒"></a>StrictMode 下的新提醒</h2><p><code>StrictMode</code> 是用来提醒开发者用了即将被废弃的 <code>API</code> 的，像 <code>componentWillMount</code> 这些声明周期都会提醒，这次新加了两个 <code>API</code> 的提醒，<code>ReactDOM.findDOMNode()</code>，和老的 <code>context api</code>。</p><p>也代表着这两个下个大版本肯定会被移除。所以兄弟们还不赶紧更新！</p><p><a href="https://juejin.im/post/5bd68c446fb9a05d25682654" target="_blank" rel="noopener">原文链接</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 预解释是一种毫无节操的机制</title>
      <link href="/pre-interpretation/"/>
      <url>/pre-interpretation/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pre-interpretation-1.png" alt=""></p><h2 id="什么是预解释"><a href="#什么是预解释" class="headerlink" title="什么是预解释"></a>什么是预解释</h2><p>js 代码执行之前，浏览器首先会默认的把所有带 var 和 function 的进行提前的声明或者定义</p><a id="more"></a><h3 id="理解声明和定义"><a href="#理解声明和定义" class="headerlink" title="理解声明和定义"></a>理解声明和定义</h3><p>声明(declare):如 var num;=&gt;告诉浏览器在全局作用域中有一个 num 的变量了；如果一个变量只是声明了但是没有赋值，默认的值是 undefined</p><p>定义(defined):如 num=12;=&gt;给我们的变量进行赋值。</p><h3 id="对于带-var-和-function-关键字的在预解释的时候操作不一样的"><a href="#对于带-var-和-function-关键字的在预解释的时候操作不一样的" class="headerlink" title="对于带 var 和 function 关键字的在预解释的时候操作不一样的"></a>对于带 var 和 function 关键字的在预解释的时候操作不一样的</h3><p>var =&gt;在预解释的时候只是提前的声明</p><p>function =&gt;在预解释的时候提前的声明+定义都完成了</p><h3 id="预解释只发生在当前的作用域下。"><a href="#预解释只发生在当前的作用域下。" class="headerlink" title="预解释只发生在当前的作用域下。"></a>预解释只发生在当前的作用域下。</h3><p>例如：开始只对 window 下的进行预解释，只有函数执行的时候才会对函数中的进行预解释</p><h2 id="作用域链与闭包"><a href="#作用域链与闭包" class="headerlink" title="作用域链与闭包"></a>作用域链与闭包</h2><h3 id="如何区分私有变量和全局变量？"><a href="#如何区分私有变量和全局变量？" class="headerlink" title="如何区分私有变量和全局变量？"></a>如何区分私有变量和全局变量？</h3><ul><li><strong>在全局作用域下声明（预解释的时候）的变量是全局变量</strong></li><li><strong>只有函数执行会产生私有的作用域,比如 for(){}、if(){}和 switch(){}都不会产生私有作用域</strong></li><li><strong>在”私有作用域中声明的变量(var 声明)”和”函数的形参”都是私有的变量</strong>。在私有作用域中，代码执行的时保遇到了一个变量，首先我们需要确定它是否为私有的变量，如果是私有的变量，那么和外面的没有在何的关系；如果不是私有的，则往当前作用域的上级作用域进行查找，如果上级作用域也没有则继续查找，一直找到 window 为止，这就是作用域链。</li></ul><p>我们举个例子来区别私有变量和全局变量：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//=&gt;变量提升：var a；var b；var c；test=AAAFFF111；</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="number">10</span>,b=<span class="number">11</span>,c=<span class="number">12</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//=&gt;私有作用域：a=10 var b；</span></span><br><span class="line">  a=<span class="number">1</span>;<span class="comment">//=&gt;私有变量a=1</span></span><br><span class="line">  <span class="keyword">var</span> b=<span class="number">2</span>；<span class="comment">//=&gt;私有变量b=2</span></span><br><span class="line">  c=<span class="number">3</span>;<span class="comment">//=&gt;全局变量c=3</span></span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">10</span>）；</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(b):<span class="comment">//11</span></span><br><span class="line"><span class="built_in">console</span>.log(c);<span class="comment">//3</span></span><br></pre></td></tr></table></figure><p><strong>判断是否是私有变量一个标准就是是否是在函数中 var 声明的变量和函数的形参都是私有的变量</strong>。本道题目在 test 函数中 a 是形参和 var b 定义的变量 b 都是私有变量。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><strong>闭包是一种机制，函数执行时形成一个新的私有的作用域保护了里面的私有变量不受外界的干扰（外面修改不了私有的，私有的也修改不了外面的）</strong></p><ul><li>这是因为当函数执行的时候,首先会形成一个新的私有的作用域，然后按照如下的步骤执行：如果有形参，先给形参赋值</li><li>进行私有作用域中的预解释</li><li>私有作用域中的代码从上到下执行</li></ul><p>我们来看一道例题</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> total=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(total);<span class="comment">//-&gt;undefined 外面修改不了私有的</span></span><br><span class="line">  <span class="keyword">var</span> total=num1 +num2；</span><br><span class="line">  <span class="built_in">console</span>.log(total);<span class="comment">//-&gt;300</span></span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line"><span class="built_in">console</span>.log(total);<span class="comment">//-&gt;0 私有的也修改不了外面的</span></span><br></pre></td></tr></table></figure><h3 id="JS-中内存的分类"><a href="#JS-中内存的分类" class="headerlink" title="JS 中内存的分类"></a>JS 中内存的分类</h3><p>栈内存：用来提供一个供 JS 代码执行的环境，即作用域（全局作用域/私有的作用域）<br>堆内存：用来存储引用数据类型的值。对象存储的是属性名和属性值，函数存储的是代码字符串。</p><h2 id="var-num-12-与-num-12-有啥区别？"><a href="#var-num-12-与-num-12-有啥区别？" class="headerlink" title="var num=12 与 num=12 有啥区别？"></a>var num=12 与 num=12 有啥区别？</h2><p>我们先来看以下两个例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例题1</span></span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">//-&gt;undefined</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">12</span>;</span><br><span class="line"><span class="comment">//例题2</span></span><br><span class="line"><span class="built_in">console</span>.log(num2); <span class="comment">//-&gt;Uncaught ReferenceError:num2 is not defined</span></span><br><span class="line">num2 = <span class="number">12</span>; <span class="comment">//不能预解释</span></span><br></pre></td></tr></table></figure><p>当你看到 var num=12 时，可能会认为这是个声明。但<strong>JavaScript 实际上会将其看成两个声明：var num;和 num=12;第一个定义声明是在预解释阶段进行的。第二个赋值声明会被留在原地等待执行阶段。</strong></p><p><strong>最大区别：带 var 的可以进行预解释，所以在赋值的前面执行不会报错；不带 var 的是不能进行预解释的，在前面执行会报错；</strong></p><p>除此之外，num2=12; 相当于给 window 增加了一个叫做 num2 的属性名，属性值是 12,而 var num=12; 首先它相当于给全局作用域增加了一个全局变量 num，它也相当于给 window 增加了一个属性名 num，属性值是 12。</p><p>接下来我们举例说明：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例题1</span></span><br><span class="line"><span class="keyword">var</span> total=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(total);<span class="comment">//undefined</span></span><br><span class="line">  <span class="keyword">var</span> total=<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line"><span class="built_in">console</span>.log(total);<span class="comment">//0</span></span><br><span class="line"><span class="comment">//例题2</span></span><br><span class="line"><span class="keyword">var</span> total=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(total);<span class="comment">//0</span></span><br><span class="line">  total=<span class="number">100</span>；</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line"><span class="built_in">console</span>.log(total);<span class="comment">//100</span></span><br></pre></td></tr></table></figure><p>例题 1 中带 var 变量在私有作用域中可以预解释，所以第一个 console 打出来的值为 undefined。<strong>私有作用域中出现的一个变量不是私有的，则往上级作用域进行查找，上级没有则继续向上查找，一直找到 window 为止</strong>，例题 2 中不带 var 变量不是私有的，所以往上级找</p><h2 id="预解释五大毫无节操的表现"><a href="#预解释五大毫无节操的表现" class="headerlink" title="预解释五大毫无节操的表现"></a>预解释五大毫无节操的表现</h2><p><strong>1、预解释的时候不管你的条件是否成立，都要把带 var 的进行提前的声明。</strong></p><p>请看下面这道例题：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>（!(<span class="string">"num"</span> <span class="keyword">in</span>  <span class="built_in">window</span>))&#123;</span><br><span class="line">  <span class="keyword">var</span> num=<span class="number">12</span>；<span class="comment">//这句话会被提到大括号之外的全局作用域：var num;-&gt;window.num；</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p><strong>2、预解释的时候只预解释”=”左边的，右边的值，不参与预解释</strong></p><p>请看下面这道例题：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn(); <span class="comment">//报错</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//window下的预解释：var fn；</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"ok"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>3、自执行函数：定义和执行一起完成了。</strong></p><p>自执行函数定义的那个 function 在全局作用域下不进行预解释，当代码执行到这个位置的时候定义和执行一起完成了。常见有以下几种形式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;&#125;)(<span class="number">10</span>);</span><br><span class="line">~<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;&#125;(<span class="number">10</span>);</span><br><span class="line">+<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;&#125;(<span class="number">10</span>);</span><br><span class="line">-<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;&#125;(<span class="number">10</span>);</span><br><span class="line">！<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;&#125;(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><strong>4、函数体中 return 下面的代码虽然不再执行了，但是需要进行预解释；return 后面跟着的都是我们返回的值，所以不进行预解释；</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//预解释：var num；</span></span><br><span class="line">  <span class="built_in">console</span>.log(num）;<span class="comment">//-&gt;undefined</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> num=<span class="number">100</span>;</span><br></pre></td></tr></table></figure><p><strong>5、函数声明和变量声明都会被提升。但是一个值得注意的细节（这个细节可以出现在有多个“重复”声明的代码中）是函数会首先被提升，然后才是变量。在预解释的时候，如果名字已经声明过了，不需要从新的声明，但是需要重新的赋值；</strong></p><p>我们先来看下两个简单的例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例题1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">//'function'</span></span><br><span class="line"><span class="comment">//例题2</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(c);</span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">c(<span class="number">2</span>); <span class="comment">//Uncaught TypeError: c is not a function</span></span><br></pre></td></tr></table></figure><p>当遇到存在函数声明和变量声明都会被提升的情况，函数声明优先级比较高，最后变量声明会被函数声明所覆盖，但是可以重新赋值,所以上个例子可以等价为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(c);</span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">c = <span class="number">1</span>;</span><br><span class="line">c(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>接下来我们看下两道比较复杂的题目:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例题3</span></span><br><span class="line">fn();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line"><span class="keyword">var</span> fn = <span class="number">10</span>;</span><br><span class="line">fn();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><blockquote><ul><li>一开始预解释，函数声明和赋值一起来，fn 就是 function fn(){console.log(1);}；遇到 var fn=10;不会重新再声明，但是遇到 function fn(){console.log(2);}就会从重新赋值，所以一开始 fn()的值就是 2</li></ul></blockquote><ul><li>再执行 fn();值不变还是 2</li><li>fn 重新赋值为 10，所以运行 fn()时报错，接下去的语句就没再执行。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例题4</span></span><br><span class="line">alert(a);</span><br><span class="line">a();</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">alert(a);</span><br><span class="line">a = <span class="number">6</span>;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><blockquote><ul><li>函数声明优先于变量声明，预解释时候，函数声明和赋值一起来，a 就是 function a(){alert(10)} ，后面遇到 var a=3，也无需再重复声明，所以先弹出 function a(){alert(10)}</li></ul></blockquote><ul><li>a()，执行函数，然后弹出 10</li><li>接着执行了 var a=3; 所以 alert(a)就是显示 3</li><li>由于 a 不是一个函数了，所以往下在执行到 a()的时候， 报错。</li></ul><p><a href="https://github.com/ljianshu/Blog/issues/3" target="_blank" rel="noopener">原文链接</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 数据类型及检测</title>
      <link href="/js-type-check/"/>
      <url>/js-type-check/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/js-type-check-1.png" alt=""></p><h2 id="JavaScript-有几种类型的值？"><a href="#JavaScript-有几种类型的值？" class="headerlink" title="JavaScript 有几种类型的值？"></a>JavaScript 有几种类型的值？</h2><p>javascript 有两种数据类型，分别是基本数据类型和引用数据类型。其中基本数据类型包括 Undefined、Null、Boolean、Number、String、Symbol (ES6 新增，表示独一无二的值)，而引用数据类型统称为 Object 对象，主要包括对象、数组和函数。接下来我们分别看下两者的特点。</p><a id="more"></a><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="值是不可变的"><a href="#值是不可变的" class="headerlink" title="值是不可变的"></a>值是不可变的</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"java"</span>;</span><br><span class="line">name.toUpperCase(); <span class="comment">// 输出 'JAVA'</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 输出  'java'</span></span><br></pre></td></tr></table></figure><p>由此可得，基本数据类型的值是不可改变的</p><h3 id="存放在栈区"><a href="#存放在栈区" class="headerlink" title="存放在栈区"></a>存放在栈区</h3><p>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</p><h3 id="值的比较"><a href="#值的比较" class="headerlink" title="值的比较"></a>值的比较</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a == b); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a === b); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>== : 只进行值的比较,会进行数据类型的转换。</li><li>=== : 不仅进行值得比较，还要进行数据类型的比较。</li></ul><h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><h3 id="值是可变的"><a href="#值是可变的" class="headerlink" title="值是可变的"></a>值是可变的</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=&#123;<span class="attr">age</span>:<span class="number">20</span>&#125;；</span><br><span class="line">a.age=<span class="number">21</span>；</span><br><span class="line"><span class="built_in">console</span>.log(a.age)<span class="comment">//21</span></span><br></pre></td></tr></table></figure><p>上面代码说明引用类型可以拥有属性和方法，并且是可以动态改变的。</p><h3 id="同时保存在栈内存和堆内存"><a href="#同时保存在栈内存和堆内存" class="headerlink" title="同时保存在栈内存和堆内存"></a>同时保存在栈内存和堆内存</h3><p>引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。<strong>当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</strong></p><p><img src="/images/js-type-check-2.png" alt=""></p><h3 id="比较是引用的比较"><a href="#比较是引用的比较" class="headerlink" title="比较是引用的比较"></a>比较是引用的比较</h3><p>当从一个变量向另一个变量赋引用类型的值时，同样也会将存储在变量中的对象的值复制一份放到为新变量分配的空间中。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">age</span>: <span class="number">20</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">b.age = <span class="number">21</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.age == b.age); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>上面我们讲到基本类型和引用类型存储于内存的位置不同，引用类型存储在堆中的对象，与此同时，在栈中存储了指针，而这个指针指向正是堆中实体的起始位置。变量 a 初始化时，a 指针指向对象{age:20}的地址，a 赋值给 b 后,b 又指向该对象{age:20}的地址，这两个变量指向了同一个对象。因此，改变其中任何一个变量，都会相互影响。</p><p><img src="/images/js-type-check-3.png" alt=""></p><p>此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">age</span>: <span class="number">20</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b; <span class="comment">// &#123;age:20&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，a 和 b 指向同一个对象，然后 a 的值变为 1，这时不会对 b 产生影响，b 还是指向原来的那个对象。</p><h2 id="检验数据类型"><a href="#检验数据类型" class="headerlink" title="检验数据类型"></a>检验数据类型</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>typeof 返回一个表示数据类型的字符串，返回结果包括：number、boolean、string、symbol、object、undefined、function 等 7 种数据类型，但不能判断 null、array 等</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(); <span class="comment">// symbol 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">""</span>; <span class="comment">// string 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>; <span class="comment">// number 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">//boolean 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">//undefined 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Function</span>(); <span class="comment">// function 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">//object 无效</span></span><br><span class="line"><span class="keyword">typeof</span> []; <span class="comment">//object 无效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">//object 无效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(); <span class="comment">//object 无效</span></span><br></pre></td></tr></table></figure><p>数组和对象返回的都是 object，这时就需要使用 instanceof 来判断</p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>instanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">//true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>() <span class="keyword">instanceof</span> <span class="built_in">Date</span>;<span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>() <span class="keyword">instanceof</span> <span class="built_in">RegExp</span><span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>关于数组的类型判断，还可以用 ES6 新增 Array.isArray()</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray([]); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>instanceof 三大弊端：</strong></p><ul><li><p>对于基本数据类型来说，字面量方式创建出来的结果和实例方式创建的是有一定的区别的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>) <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>从严格意义上来讲，只有实例创建出来的结果才是标准的对象数据类型值，也是标准的 Number 这个类的一个实例；对于字面量方式创建出来的结果是基本的数据类型值，不是严谨的实例，但是由于 JS 的松散特点，导致了可以使用 Number.prototype 上提供的方法。</p></li><li><p>只要在当前实例的原型链上，我们用其检测出来的结果都是 true。在类的原型继承中，我们最后检测出来的结果未必准确。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(fn <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>不能检测 null 和 undefined</p><p><strong>对于特殊的数据类型 null 和 undefined，他们的所属类是 Null 和 Undefined，但是浏览器把这两个类保护起来了，不允许我们在外面访问使用。</strong></p></li></ul><p><img src="/images/js-type-check-4.png" alt=""></p><h3 id="严格运算符"><a href="#严格运算符" class="headerlink" title="严格运算符==="></a>严格运算符===</h3><p><strong>只能用于判断 null 和 undefined，因为这两种类型的值都是唯一的。</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">typeof</span> a; <span class="comment">// "object"</span></span><br><span class="line">a === <span class="literal">null</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>undefined 还可以用 typeof 来判断</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">typeof</span> b === <span class="string">"undefined"</span>; <span class="comment">// true</span></span><br><span class="line">b === <span class="literal">undefined</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>constructor 作用和 instanceof 非常相似。<strong>但 constructor 检测 Object 与 instanceof 不一样，还可以处理基本数据类型的检测。</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aa = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(aa.constructor === <span class="built_in">Array</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(aa.constructor === <span class="built_in">RegExp</span>); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">1</span>).constructor === <span class="built_in">Number</span>); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^$/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.constructor === <span class="built_in">RegExp</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.constructor === <span class="built_in">Object</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p><strong>constructor 两大弊端：</strong></p><ul><li><p>null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。</p></li><li><p>函数的 constructor 是不稳定的，这个主要体现在把类的原型进行重写，在重写的过程中很有可能出现把之前的 constructor 给覆盖了，这样检测出来的结果就是不准确的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Fn.prototype = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="built_in">console</span>.log(f.constructor); <span class="comment">//Array</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h3><p><strong>Object.prototype.toString.call() 最准确最常用的方式</strong>。首先获取 Object 原型上的 toString 方法，让方法执行，让 toString 方法中的 this 指向第一个参数的值。</p><p><strong>关于 toString 重要补充说明：</strong></p><ul><li><p>本意是转换为字符串，但是某些 toString 方法不仅仅是转换为字符串</p></li><li><p>对于 Number、String，Boolean，Array，RegExp、Date、Function 原型上的 toString 方法都是把当前的数据类型转换为字符串的类型（它们的作用仅仅是用来转换为字符串的）</p></li><li><p>Object 上的 toString 并不是用来转换为字符串的。</p><p>Object 上的 toString 它的作用是返回当前方法执行的主体（方法中的 this）所属类的详细信息即”[object Object]”,其中第一个 object 代表当前实例是对象数据类型的(这个是固定死的)，第二个 Object 代表的是 this 所属的类是 Object。</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">""</span>); <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>); <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>); <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>); <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>); <span class="comment">// [object Null]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Function</span>()); <span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">// [object Date]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]); <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">RegExp</span>()); <span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Error</span>()); <span class="comment">// [object Error]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>); <span class="comment">// [object HTMLDocument]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>); <span class="comment">//[object global] window是全局对象global的引用</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://segmentfault.com/a/1190000002789651" target="_blank" rel="noopener">[ JS 进阶 ] 基本类型 引用类型 简单赋值 对象引用（推荐）</a></li><li><a href="https://blog.csdn.net/donggx/article/details/71453103" target="_blank" rel="noopener">JS 判断数据类型的三种方法</a></li><li><a href="https://github.com/muwenzi/Program-Blog/issues/17" target="_blank" rel="noopener">JS 中的数据类型及判断</a></li><li><a href="https://juejin.im/entry/5964a1c15188250d8b65ef5f" target="_blank" rel="noopener">Javascript 判断变量类型的陷阱 与 正确的处理方式</a></li><li><a href="https://www.cnblogs.com/onepixel/p/5126046.html" target="_blank" rel="noopener">判断 JS 数据类型的四种方法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 运行机制</title>
      <link href="/event-loop/"/>
      <url>/event-loop/</url>
      
        <content type="html"><![CDATA[<h2 id="理解-JS-的单线程的概念"><a href="#理解-JS-的单线程的概念" class="headerlink" title="理解 JS 的单线程的概念"></a>理解 JS 的单线程的概念</h2><p>JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么 JavaScript 不能有多个线程呢？这样能提高效率啊。</p><p><img src="/images/event-loop-1.png" alt=""></p><p>JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><a id="more"></a><p>所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p><p><img src="/images/event-loop-1.png" alt=""></p><p><strong>浏览器事件环中 js 分为两部分，一个叫 heap（堆），一个叫 stack（栈）。</strong></p><p>对象放在 heap（堆）里，常见的基础类型和函数放在 stack（栈）里，函数执行的时候在栈里执行。栈里函数执行的时候可能会调一些 Dom 操作，ajax 操作和 setTimeout 定时器，这时候要等 stack（栈）里面的所有程序先走（注意：栈里的代码是先进后出），走完后再走 WebAPIs，WebAPIs 执行后的结果放在 callback queue（回调的队列里，注意：队列里的代码先放进去的先执行），也就是当栈里面的程序走完之后，再从任务队列中读取事件，将队列中的事件放到执行栈中依次执行，这个过程是循环不断的。</p><p>简单来讲：</p><ol><li>所有同步任务都在主线程上执行，形成一个执行栈</li><li>主线程之外，还存在一个任务队列。只要异步任务有了运行结果，就在任务队列之中放置一个事件。</li><li>一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列,将队列中的事件放到执行栈中依次执行</li><li>主线程从任务队列中读取事件，这个过程是循环不断的</li></ol><p>整个的这种运行机制又称为 Event Loop(事件循环)</p><p><strong>栈方法 LIFO（Last In First Out）：先进后出（先进的后出），典型的就是函数调用。</strong><br><strong>队列方法 FIFO（First In First Out）</strong></p><h2 id="理解任务队列-消息队列"><a href="#理解任务队列-消息队列" class="headerlink" title="理解任务队列(消息队列)"></a>理解任务队列(消息队列)</h2><p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。JavaScript 语言的设计者意识到这个问题，将所有任务分成两种，<strong>一种是同步任务（synchronous），另一种是异步任务（asynchronous）</strong>。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p><p><strong>异步任务包括宏任务和微任务(后面会重点介绍)</strong>。<br>接下来我们通过两个例子说明同步任务和异步任务的区别：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"A"</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123; &#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"B"</span>);</span><br><span class="line">请问最后的输出结果是什么？</span><br></pre></td></tr></table></figure><p>如果你的回答是 A,恭喜你答对了，因为这是同步任务，程序由上到下执行，遇到 while()死循环，下面语句就没办法执行。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"A"</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"B"</span>);</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;&#125;</span><br><span class="line">请问最后的输出结果是什么？</span><br></pre></td></tr></table></figure><p>如果你的答案是 A，恭喜你现在对 js 运行机制已经有个粗浅的认识了！题目中的 setTimeout()就是个异步任务。在所有同步任务执行完之前，任何的异步任务是不会执行的，关于这点下文还会详细说明。</p><h2 id="理解-Event-Loop"><a href="#理解-Event-Loop" class="headerlink" title="理解 Event Loop"></a>理解 Event Loop</h2><p><strong>异步执行的运行机制如下：</strong></p><ul><li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</li><li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li><li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li><li>主线程不断重复上面的第三步。</li></ul><p><strong>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）。只要主线程空了，就会去读取”任务队列”，这就是 JavaScript 的运行机制</strong>。<br>这个过程会循环反复。以下这张图可以很好说明这点。</p><p><img src="/images/event-loop-2.png" alt=""></p><h2 id="哪些语句会放入异步任务队列及放入时机"><a href="#哪些语句会放入异步任务队列及放入时机" class="headerlink" title="哪些语句会放入异步任务队列及放入时机"></a>哪些语句会放入异步任务队列及放入时机</h2><p>一般来说，有以下四种会放入异步任务队列：</p><ul><li>setTimeout 和 setlnterval</li><li>DOM 事件</li><li>ES6 中的 Promise</li><li>Ajax 异步请求</li></ul><p><strong>javascript 代码运行分两个阶段：</strong></p><ul><li><p><strong>1、预解析—把所有的函数定义提前，所有的变量声明提前，变量的赋值不提前</strong></p></li><li><p><strong>2、执行—从上到下执行（按照 js 运行机制）</strong></p></li></ul><p>至于放入异步任务队列的时机，我们通过 setTimeout 的例子和 Ajax 例子来详细说明：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">请问最后的输出结果是什么？</span><br></pre></td></tr></table></figure><p>for 循环一次碰到一个 setTimeout()，<strong>并不是马上把 setTimeout()拿到异步队列中，而要等到一秒后，才将其放到任务队列里面</strong>，一旦”执行栈”中的所有同步任务执行完毕（即 for 循环结束，此时 i 已经为 5），系统就会读取已经存放”任务队列”的 setTimeout()（有五个），于是答案是输出 5 个 5。</p><p>上面也提到，<strong>在到达指定时间时，定时器就会将相应回调函数插入“任务队列”尾部。这就是“定时器（timer）”功能</strong>。</p><p><strong>关于定时器的重要补充：</strong></p><p>定时器包括 setTimeout 与 setInterval 两个方法。它们的第二个参数是指定其回调函数推迟/每隔多少毫秒数后执行。</p><p>对于第二个参数有以下需要注意的地方：</p><p>当第二个参数缺省时，默认为 0；</p><p>当指定的值小于 4 毫秒，则增加到 4ms(4ms 是 HTML5 标准指定的，对于 2010 年及之前的浏览器则是 10ms);也就是说至少需要 4 毫秒，该 setTimeout()拿到任务队列中。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url：“xxxxx<span class="string">",</span></span><br><span class="line"><span class="string">  success:function (result)&#123;</span></span><br><span class="line"><span class="string">    console.log("</span>a<span class="string">")</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">setTimeout(function ()&#123;</span></span><br><span class="line"><span class="string">  console.log("</span>b<span class="string">")</span></span><br><span class="line"><span class="string">&#125;,100)</span></span><br><span class="line"><span class="string">setTimeout(function ()&#123;</span></span><br><span class="line"><span class="string">  console.log("</span>c<span class="string">")</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">console.log("</span>d<span class="string">");</span></span><br></pre></td></tr></table></figure><p><img src="/images/event-loop-3.png" alt=""></p><blockquote><p>ajax 加载完成时才会放入异步队列，至于这段时间不确定，所有有两种情况：① 大于 100ms,最后的结果是 d c b a ;② 小于 100ms,最后的结果便是 d c a b。</p></blockquote><h2 id="微任务-Microtask-与宏任务-Macrotask"><a href="#微任务-Microtask-与宏任务-Macrotask" class="headerlink" title="微任务(Microtask)与宏任务(Macrotask)"></a>微任务(Microtask)与宏任务(Macrotask)</h2><p>我们上面提到异步任务分为宏任务和微任务，宏任务队列可以有多个，微任务队列只有一个。</p><ul><li>宏任务包括：script(全局任务), setTimeout, setInterval, setImmediate, I/O, UI rendering。</li><li>微任务包括: new Promise().then(回调), process.nextTick, Object.observe(已废弃), MutationObserver(html5 新特性), MessageChannel(消息通道，类似 worker)</li></ul><p><strong>当执行栈中的所有同步任务执行完毕时，是先执行宏任务还是微任务呢？</strong></p><ul><li>由于执行代码入口都是全局任务 script，而全局任务属于宏任务，所以当栈为空，同步任务任务执行完毕时，会先执行微任务队列里的任务。</li><li>微任务队列里的任务全部执行完毕后，会读取宏任务队列中拍最前的任务。</li><li>执行宏任务的过程中，遇到微任务，依次加入微任务队列。</li><li>栈空后，再次读取微任务队列里的任务，依次类推。</li></ul><p>一句话：<strong>当某个宏任务队列的中的任务全部执行完以后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，就查看是否有其他宏任务队列。</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">接下来我们看两道例子来介绍上面流程：</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>)</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>最后输出结果是 Promise1，setTimeout1，Promise2，setTimeout2</p><ul><li>一开始执行栈的同步任务执行完毕，会去查看是否有微任务队列，上题中存在(有且只有一个)，然后执行微任务队列中的所有任务输出 Promise1，同时会生成一个宏任务 setTimeout2</li><li>然后去查看宏任务队列，宏任务 setTimeout1 在 setTimeout2 之前，先执行宏任务 setTimeout1，输出 setTimeout1</li><li>在执行宏任务 setTimeout1 时会生成微任务 Promise2 ，放入微任务队列中，接着先去清空微任务队列中的所有任务，输出 Promise2</li><li>清空完微任务队列中的所有任务后，就又会去宏任务队列取一个，这回执行的是 setTimeout2</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>JavaScript 运行机制详解：再谈 Event Loop</li><li>关于 JavaScript 单线程的一些事</li><li>JS 事件循环机制（event loop）之宏任务/微任务</li><li>前端基础进阶（十二）：深入核心，详解事件循环机制</li><li>事件循环机制的那些事</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> EvevtLoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写好 JS 条件语句的 5 条守则</title>
      <link href="/good-js-five-rules/"/>
      <url>/good-js-five-rules/</url>
      
        <content type="html"><![CDATA[<p>在用 JavaScript 工作时，我们经常和条件语句打交道，这里有 5 条让你写出更好/干净的条件语句的建议。</p><ol><li>多重判断时使用 Array.includes</li><li>更少的嵌套，尽早 return</li><li>使用默认参数和解构</li><li>倾向于遍历对象而不是 Switch 语句</li><li>对 所有/部分 判断使用 Array.every &amp; Array.some</li></ol><a id="more"></a><h2 id="多重判断时使用-Array-includes"><a href="#多重判断时使用-Array-includes" class="headerlink" title="多重判断时使用 Array.includes"></a>多重判断时使用 Array.includes</h2><p>让我们看一下下面这个例子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// condition</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">fruit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fruit == <span class="string">"apple"</span> || fruit == <span class="string">"strawberry"</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"red"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一眼，上面这个例子看起来没问题。如果我们有更多名字叫 cherry 和 cranberries 的红色水果呢？我们准备用更多的 || 来拓展条件语句吗？</p><p>我们可以用 Array.includes (Array.includes)重写条件语句。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">fruit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> redFruits = [<span class="string">"apple"</span>, <span class="string">"strawberry"</span>, <span class="string">"cherry"</span>, <span class="string">"cranberries"</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (redFruits.includes(fruit)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"red"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把红色的水果(red fruits)这一判断条件提取到一个数组。这样一来，代码看起来更整洁。</p><h2 id="更少的嵌套，尽早-Return"><a href="#更少的嵌套，尽早-Return" class="headerlink" title="更少的嵌套，尽早 Return"></a>更少的嵌套，尽早 Return</h2><p>让我们拓展上一个例子让它包含两个条件。</p><p>如果没有传入参数 fruit，抛出错误<br>接受 quantity 参数，并且在 quantity 大于 10 时打印出来</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">fruit, quantity</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> redFruits = [<span class="string">"apple"</span>, <span class="string">"strawberry"</span>, <span class="string">"cherry"</span>, <span class="string">"cranberries"</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 条件 1: fruit 必须有值</span></span><br><span class="line">  <span class="keyword">if</span> (fruit) &#123;</span><br><span class="line">    <span class="comment">// 条件 2: 必须是red的</span></span><br><span class="line">    <span class="keyword">if</span> (redFruits.includes(fruit)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"red"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 条件 3: quantity大于10</span></span><br><span class="line">      <span class="keyword">if</span> (quantity &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"big quantity"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"No fruit!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试结果</span></span><br><span class="line">test(<span class="literal">null</span>); <span class="comment">// error: No fruits</span></span><br><span class="line">test(<span class="string">"apple"</span>); <span class="comment">// print: red</span></span><br><span class="line">test(<span class="string">"apple"</span>, <span class="number">20</span>); <span class="comment">// print: red, big quantity</span></span><br></pre></td></tr></table></figure><p>在上面的代码, 我们有:</p><p>1 个 if/else 语句筛选出无效的语句，3 层 if 嵌套语句 (条件 1, 2 &amp; 3)，我个人遵循的规则一般是在发现无效条件时，尽早 Return。当发现无效语句时，尽早 Return。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">fruit, quantity</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> redFruits = [<span class="string">"apple"</span>, <span class="string">"strawberry"</span>, <span class="string">"cherry"</span>, <span class="string">"cranberries"</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 条件 1: 尽早抛出错误</span></span><br><span class="line">  <span class="keyword">if</span> (!fruit) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"No fruit!"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 条件 2: 必须是红色的</span></span><br><span class="line">  <span class="keyword">if</span> (redFruits.includes(fruit)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"red"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 条件 3: 必须是大质量的</span></span><br><span class="line">    <span class="keyword">if</span> (quantity &gt; <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"big quantity"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，我们少了一层嵌套语句。这种编码风格非常好，尤其是当你有很长的 if 语句的时候(想象你需要滚动到最底层才知道还有 else 语句，这并不酷)<br>我们可以通过 倒置判断条件 &amp; 尽早 return 进一步减少 if 嵌套。看下面我们是怎么处理判断 条件 2 的:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">fruit, quantity</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> redFruits = [<span class="string">"apple"</span>, <span class="string">"strawberry"</span>, <span class="string">"cherry"</span>, <span class="string">"cranberries"</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 条件 1: 尽早抛出错误</span></span><br><span class="line">  <span class="keyword">if</span> (!fruit) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"No fruit!"</span>);</span><br><span class="line">  <span class="comment">// 条件 2: 当水果不是红色时停止继续执行</span></span><br><span class="line">  <span class="keyword">if</span> (!redFruits.includes(fruit)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"red"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 条件 3: 必须是大质量的</span></span><br><span class="line">  <span class="keyword">if</span> (quantity &gt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"big quantity"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过倒置判断条件 2，我们的代码避免了嵌套语句。这个技巧在我们需要进行很长的逻辑判断时是非常有用的，特别是我们希望能够在条件不满足时能够停止下来进行处理。</p><p>而且这么做并不困难。问问自己，这个版本(没有嵌套)是不是比之前的(两层条件嵌套)更好，可读性更高？</p><p>但对于我，我会保留先前的版本(包含两层嵌套)。这是因为:</p><p>代码比较短且直接，包含 if 嵌套的更清晰<br>倒置判断条件可能加重思考的负担(增加认知载荷)<br>因此，应当尽力减少嵌套和尽早 return，但不要过度。如果你感兴趣的话，可以看一下关于这个话题的一篇文章和 StackOverflow 上的讨论。</p><p>Avoid Else, Return Early by Tim Oxley<br>StackOverflow discussion on if/else coding style</p><h2 id="使用默认参数和解构"><a href="#使用默认参数和解构" class="headerlink" title="使用默认参数和解构"></a>使用默认参数和解构</h2><p>我猜下面的代码你可能会熟悉，在 JavaScript 中我们总是需要检查 null / undefined 的值和指定默认值:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">fruit, quantity</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fruit) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 如果 quantity 参数没有传入，设置默认值为 1</span></span><br><span class="line">  <span class="keyword">const</span> q = quantity || <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`We have <span class="subst">$&#123;q&#125;</span> <span class="subst">$&#123;fruit&#125;</span>!`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test results</span></span><br><span class="line">test(<span class="string">'banana'</span>); <span class="comment">// We have 1 banana!</span></span><br><span class="line">test(<span class="string">'apple'</span>, <span class="number">2</span>); <span class="comment">// We have 2 apple!</span></span><br><span class="line"></span><br><span class="line">实际上，我们可以通过声明 默认函数参数 来消除变量 q。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">fruit, quantity = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果 quantity 参数没有传入，设置默认值为 1</span></span><br><span class="line">  <span class="keyword">if</span> (!fruit) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`We have <span class="subst">$&#123;quantity&#125;</span> <span class="subst">$&#123;fruit&#125;</span>!`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test results</span></span><br><span class="line">test(<span class="string">'banana'</span>); <span class="comment">// We have 1 banana!</span></span><br><span class="line">test(<span class="string">'apple'</span>, <span class="number">2</span>); <span class="comment">// We have 2 apple!</span></span><br></pre></td></tr></table></figure><p>这更加直观，不是吗？注意，每个声明都有自己的默认参数.</p><p>例如，我们也能给 fruit 分配默认值:function test(fruit = ‘unknown’, quantity = 1)。</p><p>如果 fruit 是一个 object 会怎么样？我们能分配一个默认参数吗？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">fruit</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当值存在时打印 fruit 的值</span></span><br><span class="line">  <span class="keyword">if</span> (fruit &amp;&amp; fruit.name) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(fruit.name);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"unknown"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test results</span></span><br><span class="line">test(<span class="literal">undefined</span>); <span class="comment">// unknown</span></span><br><span class="line">test(&#123;&#125;); <span class="comment">// unknown</span></span><br><span class="line">test(&#123; <span class="attr">name</span>: <span class="string">"apple"</span>, <span class="attr">color</span>: <span class="string">"red"</span> &#125;); <span class="comment">// apple</span></span><br></pre></td></tr></table></figure><p>看上面这个例子，我们想打印 fruit 对象中可能存在的 name 属性。否则我们将打印 unknown。我们可以通过默认参数以及解构从而避免判断条件 fruit &amp;&amp; fruit.name</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解构 - 仅仅获取 name 属性</span></span><br><span class="line"><span class="comment">// 为其赋默认值为空对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">&#123; name &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name || <span class="string">"unknown"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test results</span></span><br><span class="line">test(<span class="literal">undefined</span>); <span class="comment">// unknown</span></span><br><span class="line">test(&#123;&#125;); <span class="comment">// unknown</span></span><br><span class="line">test(&#123; <span class="attr">name</span>: <span class="string">"apple"</span>, <span class="attr">color</span>: <span class="string">"red"</span> &#125;); <span class="comment">// apple</span></span><br></pre></td></tr></table></figure><p>由于我们只需要 name 属性，我们可以用 {name} 解构出参数，然后我们就能使用变量 name 代替 fruit.name。</p><p>我们也需要声明空对象 {} 作为默认值。如果我们不这么做，当执行 test(undefined) 时，你将得到一个无法对 undefined 或 null 解构的的错误。因为在 undefined 中没有 name 属性。</p><p>如果你不介意使用第三方库，这有一些方式减少 null 的检查:</p><p>使用 Lodash get 函数<br>使用 Facebook 开源的 idx 库(with Babeljs)</p><p>这是一个使用 Lodash 的例子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">fruit</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取属性名，如果属性名不可用，赋默认值为 unknown</span></span><br><span class="line">  <span class="built_in">console</span>.log(__.get(fruit, <span class="string">'name'</span>, <span class="string">'unknown'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test results</span></span><br><span class="line">test(<span class="literal">undefined</span>); <span class="comment">// unknown</span></span><br><span class="line">test(&#123; &#125;); <span class="comment">// unknown</span></span><br><span class="line">test(&#123; <span class="attr">name</span>: <span class="string">'apple'</span>, <span class="attr">color</span>: <span class="string">'red'</span> &#125;); <span class="comment">// apple</span></span><br></pre></td></tr></table></figure><p>你可以在 jsbin 运行 demo 代码。除此之外，如果你是函数式编程的粉丝，你可能选择使用 Lodash fp，Lodash 的函数式版本(方法变更为 get 或者 getOr)。</p><h2 id="倾向于对象遍历而不是-Switch-语句"><a href="#倾向于对象遍历而不是-Switch-语句" class="headerlink" title="倾向于对象遍历而不是 Switch 语句"></a>倾向于对象遍历而不是 Switch 语句</h2><p>让我们看下面这个例子，我们想根据 color 打印出水果:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用条件语句来寻找对应颜色的水果</span></span><br><span class="line">  <span class="keyword">switch</span> (color) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"red"</span>:</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">"apple"</span>, <span class="string">"strawberry"</span>];</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"yellow"</span>:</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">"banana"</span>, <span class="string">"pineapple"</span>];</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"purple"</span>:</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">"grape"</span>, <span class="string">"plum"</span>];</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test results</span></span><br><span class="line">test(<span class="literal">null</span>); <span class="comment">// []</span></span><br><span class="line">test(<span class="string">"yellow"</span>); <span class="comment">// ['banana', 'pineapple']</span></span><br></pre></td></tr></table></figure><p>上面的代码看起来没有错误，但是我找到了一些累赘。用对象遍历实现相同的结果，语法看起来更简洁:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fruitColor = &#123;</span><br><span class="line">  red: [<span class="string">"apple"</span>, <span class="string">"strawberry"</span>],</span><br><span class="line">  yellow: [<span class="string">"banana"</span>, <span class="string">"pineapple"</span>],</span><br><span class="line">  purple: [<span class="string">"grape"</span>, <span class="string">"plum"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fruitColor[color] || [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者你也可以使用 Map 实现相同的结果:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fruitColor = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="string">"red"</span>, [<span class="string">"apple"</span>, <span class="string">"strawberry"</span>])</span><br><span class="line">  .set(<span class="string">"yellow"</span>, [<span class="string">"banana"</span>, <span class="string">"pineapple"</span>])</span><br><span class="line">  .set(<span class="string">"purple"</span>, [<span class="string">"grape"</span>, <span class="string">"plum"</span>]);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fruitColor.get(color) || [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Map 是一种在 ES2015 规范之后实现的对象类型，允许你存储 key 和 value 的值。</p><p>但我们是否应当禁止 switch 语句的使用呢？答案是不要限制你自己。从个人来说，我会尽可能的使用对象遍历，但我并不严格遵守它，而是使用对当前的场景更有意义的方式。</p><p>Todd Motto 有一篇关于 switch 语句对比对象遍历的更深入的文章，你可以在这个地方阅读<br>TL;DR; 重构语法</p><p>在上面的例子，我们能够用 Array.filter 重构我们的代码，实现相同的效果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"apple"</span>, <span class="attr">color</span>: <span class="string">"red"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"strawberry"</span>, <span class="attr">color</span>: <span class="string">"red"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"banana"</span>, <span class="attr">color</span>: <span class="string">"yellow"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"pineapple"</span>, <span class="attr">color</span>: <span class="string">"yellow"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"grape"</span>, <span class="attr">color</span>: <span class="string">"purple"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"plum"</span>, <span class="attr">color</span>: <span class="string">"purple"</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fruits.filter(<span class="function"><span class="params">f</span> =&gt;</span> f.color == color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有着不止一种方法能够实现相同的结果，我们以上展示了 4 种。</p><h2 id="对-所有-部分-判断使用-Array-every-amp-Array-some"><a href="#对-所有-部分-判断使用-Array-every-amp-Array-some" class="headerlink" title="对 所有/部分 判断使用 Array.every &amp; Array.some"></a>对 所有/部分 判断使用 Array.every &amp; Array.some</h2><p>这最后一个建议更多是关于利用 JavaScript Array 的内置方法来减少代码行数。看下面的代码，我们想要检查是否所有水果都是红色:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"apple"</span>, <span class="attr">color</span>: <span class="string">"red"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"banana"</span>, <span class="attr">color</span>: <span class="string">"yellow"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"grape"</span>, <span class="attr">color</span>: <span class="string">"purple"</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> isAllRed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 条件：所有水果都是红色</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> f <span class="keyword">of</span> fruits) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isAllRed) <span class="keyword">break</span>;</span><br><span class="line">    isAllRed = f.color == <span class="string">"red"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(isAllRed); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码那么长！我们可以通过 Array.every 减少代码行数:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"apple"</span>, <span class="attr">color</span>: <span class="string">"red"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"banana"</span>, <span class="attr">color</span>: <span class="string">"yellow"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"grape"</span>, <span class="attr">color</span>: <span class="string">"purple"</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isAllRed = fruits.every(<span class="function"><span class="params">f</span> =&gt;</span> f.color == <span class="string">"red"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(isAllRed); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在更简洁了，不是吗？相同的方式，如果我们想测试是否存在红色的水果，我们可以使用 Array.some 一行代码实现。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"apple"</span>, <span class="attr">color</span>: <span class="string">"red"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"banana"</span>, <span class="attr">color</span>: <span class="string">"yellow"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"grape"</span>, <span class="attr">color</span>: <span class="string">"purple"</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 条件：任何一个水果是红色</span></span><br><span class="line">  <span class="keyword">const</span> isAnyRed = fruits.some(<span class="function"><span class="params">f</span> =&gt;</span> f.color == <span class="string">"red"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(isAnyRed); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深拷贝与浅拷贝</title>
      <link href="/DeepCopy-ShallowCopy/"/>
      <url>/DeepCopy-ShallowCopy/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th></th><th>和原数据是否指向同一对象</th><th>第一层数据为基本数据类型</th><th>原数据中包含子对象</th></tr></thead><tbody><tr><td>赋值</td><td>是</td><td>改变会使原数据一起改变</td><td>改变会使原数据一起改变</td></tr><tr><td>浅拷贝</td><td>否</td><td>改变不会使原数据一起改变</td><td>改变会使原数据一起改变</td></tr><tr><td>深拷贝</td><td>否</td><td>改变不会使原数据一起改变</td><td>改变不会使原数据一起改变</td></tr></tbody></table><a id="more"></a><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据分为基本数据类型(String, Number, Boolean, Null, Undefined，Symbol)和对象数据类型。</p><ul><li>基本数据类型的特点：直接存储在栈(stack)中的数据</li><li>引用数据类型的特点：存储的是该对象在栈中引用，真实的数据存放在堆内存里</li></ul><p>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p><h2 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h2><p><strong>深拷贝和浅拷贝是只针对 Object 和 Array 这样的引用数据类型的。</strong></p><p>深拷贝和浅拷贝的示意图大致如下：</p><p><strong>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</strong></p><h2 id="赋值和浅拷贝的区别"><a href="#赋值和浅拷贝的区别" class="headerlink" title="赋值和浅拷贝的区别"></a>赋值和浅拷贝的区别</h2><ul><li>当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。</li><li>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。</li></ul><p>我们先来看两个例子，对比赋值与浅拷贝会对原对象带来哪些改变？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象赋值</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">"zhangsan"</span>,</span><br><span class="line">  age: <span class="string">"18"</span>,</span><br><span class="line">  language: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line">obj2.name = <span class="string">"lisi"</span>;</span><br><span class="line">obj2.language[<span class="number">1</span>] = [<span class="string">"二"</span>, <span class="string">"三"</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"obj1"</span>, obj1); <span class="comment">// &#123;name: "lisi", age: "18", language: [1, ['二','三'], [4, 5]]&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"obj2"</span>, obj2); <span class="comment">// &#123;name: "lisi", age: "18", language: [1, ['二','三'], [4, 5]]&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">"zhangsan"</span>,</span><br><span class="line">  age: <span class="string">"18"</span>,</span><br><span class="line">  language: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj3 = shallowCopy(obj1);</span><br><span class="line">obj3.name = <span class="string">"lisi"</span>;</span><br><span class="line">obj3.language[<span class="number">1</span>] = [<span class="string">"二"</span>, <span class="string">"三"</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dst = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> src) &#123;</span><br><span class="line">    <span class="keyword">if</span> (src.hasOwnProperty(prop)) &#123;</span><br><span class="line">      dst[prop] = src[prop];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"obj1"</span>, obj1); <span class="comment">// &#123;name: "zhangsan", age: "18", language: [1, ['二','三'], [4, 5]]&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"obj3"</span>, obj3); <span class="comment">// &#123;name: "lisi", age: "18", language: [1, ['二','三'], [4, 5]]&#125;</span></span><br></pre></td></tr></table></figure><p>上面例子中，obj1 是原始数据，obj2 是赋值操作得到，而 obj3 浅拷贝得到。我们可以很清晰看到对原始数据的影响，具体请看下表：</p><table><thead><tr><th></th><th>和原数据是否指向同一对象</th><th>第一层数据为基本数据类型</th><th>原数据中包含子对象</th></tr></thead><tbody><tr><td>赋值</td><td>是</td><td>改变会使原数据一起改变</td><td>改变会使原数据一起改变</td></tr><tr><td>浅拷贝</td><td>否</td><td>改变不会使原数据一起改变</td><td>改变会使原数据一起改变</td></tr><tr><td>深拷贝</td><td>否</td><td>改变不会使原数据一起改变</td><td>改变不会使原数据一起改变</td></tr></tbody></table><h2 id="浅拷贝的实现方式"><a href="#浅拷贝的实现方式" class="headerlink" title="浅拷贝的实现方式"></a>浅拷贝的实现方式</h2><p><strong>1.Object.assign()</strong></p><p>Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign()进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: &#123; <span class="attr">a</span>: <span class="string">"kobe"</span>, <span class="attr">b</span>: <span class="number">39</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">var</span> initalObj = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line">initalObj.a.a = <span class="string">"wade"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a.a); <span class="comment">//wade</span></span><br></pre></td></tr></table></figure><p>注意：<strong>当 object 只有一层的时候，是深拷贝</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  username: <span class="string">"kobe"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line">obj2.username = <span class="string">"wade"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//&#123;username: "kobe"&#125;</span></span><br></pre></td></tr></table></figure><p><strong>2.Array.prototype.concat()</strong></p><p>修改新对象会改到原对象:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, &#123; <span class="attr">username</span>: <span class="string">"kobe"</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.concat();</span><br><span class="line">arr2[<span class="number">2</span>].username = <span class="string">"wade"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure><p><strong>3.Array.prototype.slice()</strong></p><p>同样修改新对象会改到原对象:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, &#123; <span class="attr">username</span>: <span class="string">"kobe"</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> arr3 = arr.slice();</span><br><span class="line">arr3[<span class="number">2</span>].username = <span class="string">"wade"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure><p><img src="/images/DeepCopy-ShallowCopy-1.png" alt=""></p><p><strong>关于 Array 的 slice 和 concat 方法的补充说明：</strong>Array 的 slice 和 concat 方法不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。</p><p>原数组的元素会按照下述规则拷贝：</p><ul><li>如果该元素是个对象引用(不是实际的对象)，slice 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。</li><li>对于字符串、数字及布尔值来说（不是 String、Number 或者 Boolean 对象），slice 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。</li></ul><p>可能这段话晦涩难懂，我们举个例子，将上面的例子小作修改：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, &#123; <span class="attr">username</span>: <span class="string">"kobe"</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> arr3 = arr.slice();</span><br><span class="line">arr3[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr, arr3);</span><br></pre></td></tr></table></figure><p><img src="/images/DeepCopy-ShallowCopy-2.png" alt=""></p><h2 id="深拷贝的实现方式"><a href="#深拷贝的实现方式" class="headerlink" title="深拷贝的实现方式"></a>深拷贝的实现方式</h2><p><strong>1.JSON.parse(JSON.stringify())</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, &#123; <span class="attr">username</span>: <span class="string">"kobe"</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> arr4 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr));</span><br><span class="line">arr4[<span class="number">2</span>].username = <span class="string">"duncan"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr, arr4);</span><br></pre></td></tr></table></figure><p>这是因为 JSON.stringify() 方法是将一个 JavaScript 值(对象或者数组)转换为一个 JSON 字符串，不能接受函数</p><p><strong>2.手写递归方法</strong></p><p>递归方法实现深度克隆原理：<strong>遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义检测数据类型的功能函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkedType</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(target).slice(<span class="number">8</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现深度克隆---对象/数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//判断拷贝的数据类型</span></span><br><span class="line">  <span class="comment">//初始化变量result 成为最终克隆的数据</span></span><br><span class="line">  <span class="keyword">let</span> result,</span><br><span class="line">    targetType = checkedType(target);</span><br><span class="line">  <span class="keyword">if</span> (targetType === <span class="string">"Object"</span>) &#123;</span><br><span class="line">    result = &#123;&#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetType === <span class="string">"Array"</span>) &#123;</span><br><span class="line">    result = [];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//遍历目标数据</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> target) &#123;</span><br><span class="line">    <span class="comment">//获取遍历数据结构的每一项值。</span></span><br><span class="line">    <span class="keyword">let</span> value = target[i];</span><br><span class="line">    <span class="comment">//判断目标结构里的每一值是否存在对象/数组</span></span><br><span class="line">    <span class="keyword">if</span> (checkedType(value) === <span class="string">"Object"</span> || checkedType(value) === <span class="string">"Array"</span>) &#123;</span><br><span class="line">      <span class="comment">//对象/数组里嵌套了对象/数组</span></span><br><span class="line">      <span class="comment">//继续遍历获取到value值</span></span><br><span class="line">      result[i] = clone(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//获取到value值是基本的数据类型或者是函数。</span></span><br><span class="line">      result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.函数库 lodash</strong></p><p>该函数库也有提供_.cloneDeep 用来做 Deep Copy</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">"lodash"</span>);</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: &#123; <span class="attr">f</span>: &#123; <span class="attr">g</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">  c: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = _.cloneDeep(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.b.f === obj2.b.f);</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>参考文章：</p><ul><li><a href="https://www.haorooms.com/post/js_copy_sq" target="_blank" rel="noopener">什么是 js 深拷贝和浅拷贝及其实现方式</a></li><li><a href="https://www.kancloud.cn/ljw789478944/interview/397319" target="_blank" rel="noopener">JavaScript 浅拷贝和深拷贝</a></li><li><a href="https://juejin.im/post/59ac1c4ef265da248e75892b" target="_blank" rel="noopener">js 深拷贝 vs 浅拷贝</a></li><li><a href="https://segmentfault.com/a/1190000016672263" target="_blank" rel="noopener">深拷贝的终极探索（99%的人都不知道)</a></li><li><a href="https://github.com/ljianshu/Blog/issues/5" target="_blank" rel="noopener">深拷贝与浅拷贝</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 使用小技巧</title>
      <link href="/git-antic/"/>
      <url>/git-antic/</url>
      
        <content type="html"><![CDATA[<p>现在代码管理工具基本是 git 的天下了，除了一些很保守的公司还在用 svn，其他基本都是自己搭一个 gitlab，下面总结一下 git 实用技巧。</p><a id="more"></a><h3 id="本地目录如何关联远程仓库"><a href="#本地目录如何关联远程仓库" class="headerlink" title="本地目录如何关联远程仓库?"></a>本地目录如何关联远程仓库?</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add &lt;主机名&gt; &lt;网址&gt;</span><br><span class="line">git remote add origin git@github.com:wulv/scripts.git</span><br></pre></td></tr></table></figure><h3 id="如何让推送不用每次输密码？"><a href="#如何让推送不用每次输密码？" class="headerlink" title="如何让推送不用每次输密码？"></a>如何让推送不用每次输密码？</h3><p>使用 ssh 的方式，在 GitHub 的<a href="https://github.com/settings/keys设置一下SSH" target="_blank" rel="noopener">https://github.com/settings/keys设置一下SSH</a> keys，关于 SSH keys 生成的问题查看<a href="https://help.github.com/articles/connecting-to-github-with-ssh/" target="_blank" rel="noopener">https://help.github.com/articles/connecting-to-github-with-ssh/</a></p><h3 id="如何回退一个文件？"><a href="#如何回退一个文件？" class="headerlink" title="如何回退一个文件？"></a>如何回退一个文件？</h3><ul><li>如果还没 git add，使用 ctrl + z 吧，如果想回到没添加文件之前，使用 git clean -df</li><li>如果已经 git add，还没 commit，使用 git checkout – files</li><li>如果已经 git commit，还没有 push，使用 git reset <commit> files</li><li>如果已经 git push 了，使用 git revert <commit>，恢复一个指定提交。</li></ul><h3 id="已经添加到仓库的文件如何忽略不提交？"><a href="#已经添加到仓库的文件如何忽略不提交？" class="headerlink" title="已经添加到仓库的文件如何忽略不提交？"></a>已经添加到仓库的文件如何忽略不提交？</h3><p>将文件添加到.gitignore，然后 git rm files</p><h3 id="当前分支还没开发完，突然需要到另外一个分支修复紧急-bug-如何处理？"><a href="#当前分支还没开发完，突然需要到另外一个分支修复紧急-bug-如何处理？" class="headerlink" title="当前分支还没开发完，突然需要到另外一个分支修复紧急 bug 如何处理？"></a>当前分支还没开发完，突然需要到另外一个分支修复紧急 bug 如何处理？</h3><p>首先确认当前分支能否提交，可以提交的直接 commit，但一般代码没写完不好提交，就储藏工作目录与暂存区的状态到堆栈中 git stash，切换到另外一个分支修复 bug 后，切回本分支，git stash pop。</p><h3 id="仓库依赖另外一个仓库？"><a href="#仓库依赖另外一个仓库？" class="headerlink" title="仓库依赖另外一个仓库？"></a>仓库依赖另外一个仓库？</h3><p>比如本博客仓库依赖一个主题，但我想对这个主题进行一些修改，首先我从原作者的主题仓库 fork 一份到我自己仓库，做一些修改，以后原作者有更新我还是想 pull 过来，这样既享受原作者的更新，又可以自己修改一些特殊的需求。将 fork 下来的仓库与原作者的仓库关联起来：git remote add remote-name remote-url，然后更新时拉取指定远程仓库指定分支到本地仓库指定分支：git pull remoterepository branchname[:localbranch]。</p><p>在父仓库里添加子仓库：git submodule add repository-url dir，这个时候会出现一个.gitmodules 文件,这是一个配置文件，保存了项目 URL 和你拉取到的本地子目录。如果克隆了一个带子模块的项目，你必须运行两个命令：git submodule init 来初始化你的本地配置文件，git submodule update 来从那个项目拉取所有数据并检出你上层项目里所列的合适的提交。</p><h3 id="如何查看提交记录？"><a href="#如何查看提交记录？" class="headerlink" title="如何查看提交记录？"></a>如何查看提交记录？</h3><ul><li>git log：查看提交记录</li><li>git log –oneline：查看提交记录，以 oneline 形式显示，只显示一行，显示的内容时提交 hash 的前 7 位与提交消息</li><li>git log -p -times：表示查看最近 times 次提交改变的内容</li><li>git log –author=”<pattern>“： 查找某位作者的提交记录</li><li>git log –grep=”<pattern>“：搜索有某字符串的提交记录</li><li>git log –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit：图形化显示提交历史</li></ul><h3 id="比较两次提交或分支的差异？"><a href="#比较两次提交或分支的差异？" class="headerlink" title="比较两次提交或分支的差异？"></a>比较两次提交或分支的差异？</h3><ul><li>git diff：查看工作目录与暂存区的差异</li><li>git diff –cached [<commit>]：查看暂存区与指定提交（默认是 HEAD）的差异</li><li>git diff <commit>：查看工作目录与指定提交的差异</li><li>git diff <commit>：查看工作目录与指定提交的差异</li><li>git diff <commit> <commit>：查看两次指定提交的差异</li><li>git diff branchname：查看工作目录与指定分支的差异</li><li>git diff branchname branchname：查看两个指定分支间的差异</li></ul><blockquote><p>上面的所有操作后面都可以加上– dir 表示查看该目录下面的差异，在后面加上&gt;patchname.patch 表示将差异生成补丁，patchname 是补丁的名字。</p></blockquote><h3 id="有两个稳定版本，将其中一个版本的功能应用到另外一个版本？"><a href="#有两个稳定版本，将其中一个版本的功能应用到另外一个版本？" class="headerlink" title="有两个稳定版本，将其中一个版本的功能应用到另外一个版本？"></a>有两个稳定版本，将其中一个版本的功能应用到另外一个版本？</h3><p>比如某仓库有 VIP 版和普通版，分别在两个分支开发，普通版更新了一些功能，VIP 版也希望将更新应用到分支，但又不能直接将普通版的分支 merge 过来，这个时候使用：git cherry-pick <commit id>将另一个分支上面的指定提交应用到当前分支上。</p><h3 id="分支太多，如何批量删除一个星期之前分支？"><a href="#分支太多，如何批量删除一个星期之前分支？" class="headerlink" title="分支太多，如何批量删除一个星期之前分支？"></a>分支太多，如何批量删除一个星期之前分支？</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#删除一个星期之前的所有本地分支</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> $(git branch | sed /\*/d); <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$(git log -1 --before='1 week ago' -s $k)</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    git branch -D <span class="variable">$k</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PureComponent 使用指南</title>
      <link href="/PureComponent/"/>
      <url>/PureComponent/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么使用？"><a href="#为什么使用？" class="headerlink" title="为什么使用？"></a>为什么使用？</h2><p>React15.3 中新加了一个 <code>PureComponent</code> 类，顾名思义， <code>pure</code> 是纯的意思， <code>PureComponent</code> 也就是纯组件，取代其前身 <code>PureRenderMixin</code> , <code>PureComponent</code> 是优化 <code>React</code> 应用程序最重要的方法之一，易于实施，只要把继承类从 <code>Component</code> 换成 <code>PureComponent</code> 即可，可以减少不必要的 <code>render</code> 操作的次数，从而提高性能，而且可以少写 <code>shouldComponentUpdate</code> 函数，节省了点代码。</p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>当组件更新时，如果组件的 <code>props</code> 和 <code>state</code> 都没发生改变， <code>render</code> 方法就不会触发，省去 <code>Virtual DOM</code> 的生成和比对过程，达到提升性能的目的。具体就是 <code>React</code> 自动帮我们做了一层浅比较：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>._compositeType === CompositeTypes.PureClass) &#123;</span><br><span class="line">  shouldUpdate =</span><br><span class="line">    !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>shallowEqual</code> 又做了什么呢？会比较 <code>Object.keys(state | props)</code> 的长度是否一致，每一个 <code>key</code> 是否两者都有，并且是否是一个引用，也就是只比较了第一层的值，确实很浅，所以深层的嵌套数据是对比不出来的。</p><h2 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h2><h3 id="易变数据不能使用一个引用"><a href="#易变数据不能使用一个引用" class="headerlink" title="易变数据不能使用一个引用"></a>易变数据不能使用一个引用</h3><p>案例：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    items: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">  &#125;;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; items &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    items.pop();</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; items &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.state.items.map(<span class="function"><span class="params">i</span> =&gt;</span> (</span><br><span class="line">            &lt;li key=&#123;i&#125;&gt;&#123;i&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">          ))&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/u</span>l&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;<span class="keyword">delete</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会发现，无论怎么点 <code>delete</code> 按钮， <code>li</code> 都不会变少，因为 <code>items</code> 用的是一个引用， <code>shallowEqual</code> 的结果为 <code>true</code> 。改正：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; items &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">  items.pop();</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">items</span>: [].concat(items) &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样每次改变都会产生一个新的数组，也就可以 <code>render</code> 了。这里有一个矛盾的地方，如果没有 <code>items.pop();</code> 操作，每次 <code>items</code> 数据并没有变，但还是 <code>render</code> 了，这不就很操蛋么？呵呵，数据都不变，你 <code>setState</code> 干嘛？</p><h3 id="不变数据使用一个引用"><a href="#不变数据使用一个引用" class="headerlink" title="不变数据使用一个引用"></a>不变数据使用一个引用</h3><h4 id="子组件数据"><a href="#子组件数据" class="headerlink" title="子组件数据"></a>子组件数据</h4><p>上面易变数据不能使用一个引用的案例中有一个点击删除操作，如果我们删除的代码这么写：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; items &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">  items.splice(items.length - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; items &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>items</code> 的引用也是改变的，但如果 <code>items</code> 里面是引用类型数据：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">items: [&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">3</span> &#125;];</span><br></pre></td></tr></table></figure><p>这个时候</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">state.items[<span class="number">0</span>] === nextState.items[<span class="number">0</span>]; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>子组件里还是<code>re-render</code>了。这样就需要我们保证不变的子组件数据的引用不能改变。这个时候可以使用<a href="https://facebook.github.io/immutable-js/" target="_blank" rel="noopener">immutable-js</a>函数库。</p><h4 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h4><p>我们在给组件传一个函数的时候，有时候总喜欢:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">&lt;MyInput onChange=&#123;e =&gt; <span class="keyword">this</span>.props.update(e.target.value)&#125; /&gt;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">update(e) &#123;</span><br><span class="line">  <span class="keyword">this</span>.props.update(e.target.value)</span><br><span class="line">&#125;</span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">MyInput</span> <span class="attr">onChange</span>=<span class="string">&#123;this.update.bind(this)&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>由于每次 <code>render</code> 操作 <code>MyInput</code> 组件的 <code>onChange</code> 属性都会返回一个新的函数，由于引用不一样，所以父组件的 <code>render</code> 也会导致 <code>MyInput</code> 组件的 <code>render</code> ，即使没有任何改动，所以需要尽量避免这样的写法，最好这样写：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1,2</span></span><br><span class="line">update = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.props.update(e.target.value)</span><br><span class="line">&#125;</span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">MyInput</span> <span class="attr">onChange</span>=<span class="string">&#123;this.update&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="空对象、空数组或固定对象"><a href="#空对象、空数组或固定对象" class="headerlink" title="空对象、空数组或固定对象"></a>空对象、空数组或固定对象</h4><p>有时候后台返回的数据中，数组长度为 0 或者对象没有属性会直接给一个 <code>null</code> ，这时候我们需要做一些容错：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    items: [&#123; <span class="attr">name</span>: <span class="string">"test1"</span> &#125;, <span class="literal">null</span>, &#123; <span class="attr">name</span>: <span class="string">"test3"</span> &#125;]</span><br><span class="line">  &#125;;</span><br><span class="line">  store = <span class="function">(<span class="params">id, value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; items &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    items[id] = assign(&#123;&#125;, items[id], &#123; <span class="attr">name</span>: value &#125;);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">items</span>: [].concat(items) &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.state.items.map(<span class="function">(<span class="params">i, k</span>) =&gt;</span> (</span><br><span class="line">            &lt;Item</span><br><span class="line">              style=&#123;&#123; <span class="attr">color</span>: <span class="string">"red"</span> &#125;&#125;</span><br><span class="line">              store=&#123;<span class="keyword">this</span>.store&#125;</span><br><span class="line">              key=&#123;k&#125;</span><br><span class="line">              id=&#123;k&#125;</span><br><span class="line">              data=&#123;i || &#123;&#125;&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">          ))&#125;</span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当某一个子组件调用 <code>store</code> 函数改变了自己的那条属性，触发 <code>render</code> 操作，如果数据是 <code>null</code> 的话 <code>data</code> 属性每次都是一个 <code>{}</code>，<code>{} ==== {}</code> 是 <code>false</code> 的，这样无端的让这几个子组件重新 <code>render</code> 了。<code>{ color: &#39;red&#39; }</code>也是一样。</p><p>最好设置一个 <code>defaultValue</code> 为 <code>{}</code>,如下：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> defaultValue = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> style = &#123; <span class="attr">color</span>: <span class="string">'red'</span> &#125;;</span><br><span class="line">&lt;Item style=&#123;style&#125; store=&#123;<span class="keyword">this</span>.store&#125; key=&#123;k&#125; id=&#123;k&#125; data=&#123;i || defaultValue&#125; /&gt;</span><br></pre></td></tr></table></figure><h3 id="复杂状态与简单状态不要共用一个组件"><a href="#复杂状态与简单状态不要共用一个组件" class="headerlink" title="复杂状态与简单状态不要共用一个组件"></a>复杂状态与简单状态不要共用一个组件</h3><p>这点可能和 <code>PureComponent</code> 没多少关系，但做的不好可能会浪费很多性能，比如一个页面上面一部分是一个复杂的列表，下面是一个输入框，抽象代码：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">change = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">value</span>: e.target.value &#125;);</span><br><span class="line">&#125;</span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;this.state.items.map((i, k) =&gt; &lt;li key=&#123;k&#125;&gt; &#123;...&#125;&lt;/li&gt;)&#125;</span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">    &lt;input value=&#123;this.state.value&#125; onChange=&#123;this.change&#125; /&gt;</span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span>)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>表单和列表其实是没有什么关联的，表单的值也可能经常变动，但它的会给列表也带来必然的 <code>diff</code> 操作，这是没必要的，最好是给列表抽出成一个单独的 <code>PureComponent</code> 组件，这样 <code>state.items</code> 不变的话，列表就不会重新 <code>render</code> 了。</p><h3 id="与-shouldComponentUpdate-共存"><a href="#与-shouldComponentUpdate-共存" class="headerlink" title="与 shouldComponentUpdate 共存"></a>与 <code>shouldComponentUpdate</code> 共存</h3><p>如果 <code>PureComponent</code> 里有 <code>shouldComponentUpdate</code> 函数的话，直接使用 <code>shouldComponentUpdate</code> 的结果作为是否更新的依据，没有 <code>shouldComponentUpdate</code> 函数的话，才会去判断是不是 <code>PureComponent</code> ，是的话再去做 <code>shallowEqual</code> 浅比较。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个变量用来控制组件是否需要更新</span></span><br><span class="line"><span class="keyword">var</span> shouldUpdate = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// inst 是组件实例</span></span><br><span class="line"><span class="keyword">if</span> (inst.shouldComponentUpdate) &#123;</span><br><span class="line">  shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._compositeType === CompositeType.PureClass) &#123;</span><br><span class="line">    shouldUpdate =</span><br><span class="line">      !shallowEqual(prevProps, nextProps) ||</span><br><span class="line">      !shallowEqual(inst.state, nextState);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="老版本兼容写法"><a href="#老版本兼容写法" class="headerlink" title="老版本兼容写法"></a>老版本兼容写法</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React &#123; PureComponent, Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> (<span class="title">PureComponent</span> || <span class="title">Component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在老版本的 <code>React</code> 里也不会挂掉。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>PureComponent</code> 真正起作用的，只是在一些纯展示组件上，复杂组件用了也没关系，反正 <code>shallowEqual</code> 那一关就过不了，不过记得 <code>props</code> 和 <code>state</code> 不能使用同一个引用哦。</p><p><a href="http://wulv.site/2017-05-31/react-purecomponent.html" target="_blank" rel="noopener">原文链接</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Component </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出 JavaScript 闭包</title>
      <link href="/closure/"/>
      <url>/closure/</url>
      
        <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>闭包（closure）是 Javascript 语言的一个难点，面试时常被问及，也是它的特色，很多高级应用都要依靠闭包实现。本文尽可能用简单易懂的话，讲清楚闭包的概念、形成条件及其常见的面试题。</p><a id="more"></a><p>我们先来看一个例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数 fn 可以读取全局变量 n。但是，函数外部无法读取函数内部声明的变量。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(n); <span class="comment">// Uncaught ReferenceError: n is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数 fn 内部声明的变量 n，函数外是无法读取的。</p><p>如果有时需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n); <span class="comment">// 999</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，函数 f 就在函数 fn 内部，这时 fn 内部的所有局部变量，对 f 都是可见的。既然 f 可以读取 fn 的局部变量，那么只要把 f 作为返回值，我们不就可以在 fn 外部读取它的内部变量了吗！</p><h2 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么"></a>闭包是什么</h2><p>我们可以对上面代码进行如下修改：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f; <span class="comment">// fn返回了f的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = fn(); <span class="comment">// result就是 f 函数了</span></span><br><span class="line">result(); <span class="comment">// 执行result，全局作用域下没有 n 的定义，但是函数闭包，能够把定义函数的时候的作用域一起记住，输出999</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数 fn 的返回值就是函数 f，由于 f 可以读取 fn 的内部变量，所以就可以在外部获得 fn 的内部变量了。</p><p>闭包就是函数 f，即能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。<strong>闭包最大的特点，就是它可以“记住”诞生的环境，比如 f 记住了它诞生的环境 fn，所以从 f 可以得到 fn 的内部变量</strong>。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p><p><strong>那到底什么是闭包呢？</strong></p><p><strong>当函数可以记住并访问所在的词法作用域，既，使函数是在当前词法作用域之外执行，这就产生了闭包</strong>。</p><p>我个人理解，<strong>闭包就是函数中的函数(其他语言不能函数再套函数)</strong>,里面的函数可以访问外面函数的变量，外面的变量的是这个内部函数的一部分。</p><p><strong>闭包形成的条件</strong>：</p><ul><li>函数嵌套</li><li>内部函数引用外部函数的局部变量</li></ul><h2 id="闭包的特性"><a href="#闭包的特性" class="headerlink" title="闭包的特性"></a>闭包的特性</h2><p><strong>每个函数都是闭包，每个函数天生都能够记忆自己定义时所处的作用域环境</strong>。把一个函数从它定义的那个作用域，挪走，运行。这个函数居然能够记忆住定义时的那个作用域。<strong>不管函数走到哪里，定义时的作用域就带到了哪里</strong>。<br>接下来我们用两个例子来说明这个问题：</p><p>例题 1:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inner;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">250</span>;</span><br><span class="line">  inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//这个函数虽然在外面执行，但能够记忆住定义时的那个作用域，a是250</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">300</span>;</span><br><span class="line">inner(); <span class="comment">//一个函数在执行的时候，找闭包里面的变量，不会理会当前作用域。</span></span><br></pre></td></tr></table></figure><p>例题 2:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x + y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> inner = outer(<span class="number">3</span>); <span class="comment">//数字3传入outer函数后，inner函数中x便会记住这个值</span></span><br><span class="line">inner(<span class="number">5</span>); <span class="comment">//当inner函数再传入5的时候，只会对y赋值，所以最后弹出8</span></span><br></pre></td></tr></table></figure><h2 id="闭包的内存泄漏"><a href="#闭包的内存泄漏" class="headerlink" title="闭包的内存泄漏"></a>闭包的内存泄漏</h2><p>栈内存提供一个执行环境，即作用域，包括全局作用域和私有作用域,那他们什么时候释放内存的？</p><ul><li>全局作用域—-只有当页面关闭的时候全局作用域才会销毁</li><li>私有的作用域—-只有函数执行才会产生</li></ul><p><strong>一般情况下，函数执行会形成一个新的私有的作用域，当私有作用域中的代码执行完成后，我们当前作用域都会主动的进行释放和销毁。但当遇到函数执行返回了一个引用数据类型的值，并且在函数的外面被一个其他的东西给接收了，这种情况下一般形成的私有作用域都不会销毁。</strong></p><p>如下面这种情况：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn(); <span class="comment">//fn执行形成的这个私有的作用域就不能再销毁了</span></span><br></pre></td></tr></table></figure><p>也就是像上面这段代码，fn 函数内部的私有作用域会被一直占用的，发生了内存泄漏。<strong>所谓内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。闭包不能滥用，否则会导致内存泄露，影响网页的性能。闭包使用完了后，要立即释放资源，将引用变量指向 null。</strong></p><p>接下来我们看下有关于内存泄漏的一道经典面试题：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">0</span>; <span class="comment">//内部变量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//通过return返回add函数，就可以在outer函数外访问了</span></span><br><span class="line">    num++; <span class="comment">//内部函数有引用，作为add函数的一部分了</span></span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func1 = outer();</span><br><span class="line">func1(); <span class="comment">//实际上是调用add函数， 输出1</span></span><br><span class="line">func1(); <span class="comment">//输出2 因为outer函数内部的私有作用域会一直被占用</span></span><br><span class="line"><span class="keyword">var</span> func2 = outer();</span><br><span class="line">func2(); <span class="comment">// 输出1  每次重新引用函数的时候，闭包是全新的。</span></span><br><span class="line">func2(); <span class="comment">// 输出2</span></span><br></pre></td></tr></table></figure><h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><ol><li>可以读取函数内部的变量。</li><li>可以使变量的值长期保存在内存中，生命周期比较长。因此不能滥用闭包，否则会造成网页的性能问题</li><li>可以用来实现 JS 模块。</li></ol><p><strong>JS 模块:具有特定功能的 js 文件,将所有的数据和功能都封装在一个函数内部(私有的),只向外暴露一个包含 n 个方法的对象或函数,模块的使用者,只需要通过模块暴露的对象调用方法来实现对应的功能。</strong></p><p>具体请看下面的例子:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//index.html文件</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"Module.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">  Module.doSomething();</span><br><span class="line">  Module.doOtherthing();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Module.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> msg = <span class="string">"Beijing"</span>; <span class="comment">//私有数据</span></span><br><span class="line">  <span class="comment">//操作数据的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"doSomething() "</span> + msg.toUpperCase());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doOtherthing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"doOtherthing() "</span> + msg.toLowerCase());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//向外暴露对象(给外部使用的两个方法)</span></span><br><span class="line">  <span class="built_in">window</span>.Module = &#123;</span><br><span class="line">    doSomething: doSomething,</span><br><span class="line">    doOtherthing: doOtherthing</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p><img src="/images/closure-1.png" alt=""></p><h2 id="闭包的运用"><a href="#闭包的运用" class="headerlink" title="闭包的运用"></a>闭包的运用</h2><p>我们要实现这样的一个需求: 点击某个按钮, 提示”点击的是第 n 个按钮”,此处我们先不用事件代理:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>测试1<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">button</span>&gt;</span>测试2<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">button</span>&gt;</span>测试3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> btns = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"button"</span>);</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; btns.length; i++) &#123;</span></span><br><span class="line"><span class="actionscript">    btns[i].onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"第"</span> + (i + <span class="number">1</span>) + <span class="string">"个"</span>);</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>万万没想到，点击任意一个按钮，后台都是弹出“第四个”,这是因为 i 是全局变量,执行到点击事件时，此时 i 的值为 3。那该如何修改，最简单的是用 let 声明 i</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; btns.length; i++) &#123;</span><br><span class="line">  btns[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"第"</span> + (i + <span class="number">1</span>) + <span class="string">"个"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外我们可以通过闭包的方式来修改:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; btns.length; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">    btns[j].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"第"</span> + (j + <span class="number">1</span>) + <span class="string">"个"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://wangdoc.com/javascript/types/function.html#%E9%97%AD%E5%8C%85" target="_blank" rel="noopener">javascript</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
