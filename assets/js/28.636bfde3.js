(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{524:function(v,_,e){"use strict";e.r(_);var t=e(6),i=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("p",[e("img",{attrs:{src:"/images/git-compose.png",alt:"git-compose"}})]),v._v(" "),e("h2",{attrs:{id:"什么是版本控制系统"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是版本控制系统"}},[v._v("#")]),v._v(" 什么是版本控制系统")]),v._v(" "),e("p",[e("strong",[v._v("版本控制系统")]),v._v(" 是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统")]),v._v(" "),e("h3",{attrs:{id:"版本控制系统的特征"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#版本控制系统的特征"}},[v._v("#")]),v._v(" 版本控制系统的特征")]),v._v(" "),e("ol",[e("li",[v._v("存储内容")]),v._v(" "),e("li",[v._v("跟踪内容更改")]),v._v(" "),e("li",[v._v("与协作者分发内容和历史记录")])]),v._v(" "),e("p",[v._v("三大特征分别对应以下三大功能：")]),v._v(" "),e("ol",[e("li",[v._v("数据备份")]),v._v(" "),e("li",[v._v("版本存储")]),v._v(" "),e("li",[v._v("协同合作")])]),v._v(" "),e("h3",{attrs:{id:"版本控制系统发展史"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#版本控制系统发展史"}},[v._v("#")]),v._v(" 版本控制系统发展史")]),v._v(" "),e("ul",[e("li",[v._v("手动 "),e("code",[v._v("copy diff")]),v._v(" 打 "),e("code",[v._v("patch")])]),v._v(" "),e("li",[v._v("引入写入互斥锁的多人合作模式的 "),e("code",[v._v("RCS")])]),v._v(" "),e("li",[v._v("引入 "),e("code",[v._v("branch")]),v._v(" 概念采用 "),e("code",[v._v("复制-修改-合并")]),v._v(" 模式的 "),e("code",[v._v("CVS")])]),v._v(" "),e("li",[v._v("实现原子操作级别合并的集中式版本控制系统 "),e("code",[v._v("SVN")])]),v._v(" "),e("li",[v._v("分布式版本控制系统 "),e("code",[v._v("git")])])]),v._v(" "),e("blockquote",[e("p",[e("a",{attrs:{href:"http://www.cnblogs.com/vamei/archive/2013/02/21/2918069.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("版本管理三国志 (CVS, Subversion, git))"),e("OutboundLink")],1)])]),v._v(" "),e("h2",{attrs:{id:"为什么选择-git"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么选择-git"}},[v._v("#")]),v._v(" 为什么选择 git")]),v._v(" "),e("h3",{attrs:{id:"集中式代表-svn"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#集中式代表-svn"}},[v._v("#")]),v._v(" 集中式代表 SVN")]),v._v(" "),e("p",[e("img",{attrs:{src:"/images/svn.png",alt:"svn"}})]),v._v(" "),e("p",[v._v("工作模型")]),v._v(" "),e("ol",[e("li",[v._v("主工程师搭好项目框架")]),v._v(" "),e("li",[v._v("在公司服务器创建一个远程仓库，并提交代码")]),v._v(" "),e("li",[v._v("其他人拉取代码，并行开发")]),v._v(" "),e("li",[v._v("每个人独立负责一个功能，开发完成提交代码")]),v._v(" "),e("li",[v._v("其他人随时拉取代码，保持同步")])]),v._v(" "),e("p",[v._v("优点：")]),v._v(" "),e("ul",[e("li",[v._v("管理方便，逻辑明确，符合一般人思维习惯")]),v._v(" "),e("li",[v._v("易于管理，集中式服务器更能保证安全性")]),v._v(" "),e("li",[v._v("代码一致性非常高")]),v._v(" "),e("li",[v._v("适合人数不多的项目开发")])]),v._v(" "),e("p",[v._v("缺点：")]),v._v(" "),e("ul",[e("li",[v._v("服务器压力太大，数据库容量暴增")]),v._v(" "),e("li",[v._v("如果不能连接到服务器上，就不能提交，还原，对比等一系列工作")]),v._v(" "),e("li",[v._v("不适合开源项目开发人数较多的情况（但可以利用权限管理机制，通过将项目分块，管理分级实现分层管理，从而很好的解决开发人数众多的问题）")])]),v._v(" "),e("h3",{attrs:{id:"分布式代表-git"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分布式代表-git"}},[v._v("#")]),v._v(" 分布式代表 Git")]),v._v(" "),e("p",[e("img",{attrs:{src:"/images/git.png",alt:"git"}})]),v._v(" "),e("p",[v._v("工作模型")]),v._v(" "),e("ol",[e("li",[v._v("主工程师搭好项目框架 ，并提交代码到本地仓库")]),v._v(" "),e("li",[v._v("在公司服务器创建一个远程仓库，并将提交推送到远程仓库")]),v._v(" "),e("li",[v._v("其他人把远程仓库所有内容克隆到本地，拥有了各自的本地仓库，开始并行开发")]),v._v(" "),e("li",[v._v("每个人独立负责一个功能，可以把每一个小改动提交到本地（由于本地提交无需立即上传到远程仓库，所以每一步提交不必是一个完整功能，而可以是功能中的一个步骤或块）")]),v._v(" "),e("li",[v._v("功能开发完毕，将和这个功能相关的所有提交从本地推送到远程仓库")]),v._v(" "),e("li",[v._v("每次当有人把新的提交推送到远程仓库的时候，其他人就可以选择把这些提交同步到自己的机器上，并把它们和自己的本地代码合并")])]),v._v(" "),e("p",[v._v("优点：")]),v._v(" "),e("ul",[e("li",[v._v("适合分布式开发，强调个体")]),v._v(" "),e("li",[v._v("公共服务器压力和数据量都不会太大")]),v._v(" "),e("li",[v._v("速度快、灵活")]),v._v(" "),e("li",[v._v("任意两个开发者之间可以很容易的解决冲突")]),v._v(" "),e("li",[v._v("离线工作")])]),v._v(" "),e("p",[v._v("缺点：")]),v._v(" "),e("ul",[e("li",[v._v("不符合常规思维")]),v._v(" "),e("li",[v._v("学习周期相对而言比较长")]),v._v(" "),e("li",[v._v("代码权限管理划分粒度不够，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息（但可以通过项目拆分和开发者角色来管理项目）")])]),v._v(" "),e("h3",{attrs:{id:"结论"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#结论"}},[v._v("#")]),v._v(" 结论")]),v._v(" "),e("p",[e("strong",[v._v("SVN 更偏向于项目管理， Git 更适用于代码管理")])]),v._v(" "),e("blockquote",[e("p",[e("a",{attrs:{href:"https://www.cnblogs.com/Sungeek/p/9152223.html#sg3",target:"_blank",rel:"noopener noreferrer"}},[v._v("SVN与Git比较的优缺点差异"),e("OutboundLink")],1)])]),v._v(" "),e("h2",{attrs:{id:"git-原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-原理"}},[v._v("#")]),v._v(" Git 原理")]),v._v(" "),e("h3",{attrs:{id:"仓库结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#仓库结构"}},[v._v("#")]),v._v(" 仓库结构")]),v._v(" "),e("div",{staticClass:"language-sh line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-sh"}},[e("code",[v._v("└── .git\n    ├── COMMIT_EDITMSG    "),e("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 保存最新的commit message")]),v._v("\n    ├── config            "),e("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 仓库的配置文件")]),v._v("\n    ├── description       "),e("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 仓库的描述信息，主要给 gitweb 使用")]),v._v("\n    ├── HEAD              "),e("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 指向当前分支")]),v._v("\n    ├── hooks             "),e("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 存放一些 shell 脚本，可以设置特定的 git 命令后触发相应的脚本")]),v._v("\n    ├── index             "),e("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 二进制暂存区（stage）")]),v._v("\n    ├── info              "),e("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 仓库的其他信息")]),v._v("\n    │   └── exclude       "),e("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 本地的排除文件规则，功能和 .gitignore 类似")]),v._v("\n    ├── logs              "),e("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 保存所有更新操作的引用记录，主要用于git reflog 等")]),v._v("\n    ├── objects           "),e("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 所有文件的存储对象")]),v._v("\n    └── refs              "),e("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 具体的引用，主要存储分支和标签的引用")]),v._v("\n")])]),v._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[v._v("1")]),e("br"),e("span",{staticClass:"line-number"},[v._v("2")]),e("br"),e("span",{staticClass:"line-number"},[v._v("3")]),e("br"),e("span",{staticClass:"line-number"},[v._v("4")]),e("br"),e("span",{staticClass:"line-number"},[v._v("5")]),e("br"),e("span",{staticClass:"line-number"},[v._v("6")]),e("br"),e("span",{staticClass:"line-number"},[v._v("7")]),e("br"),e("span",{staticClass:"line-number"},[v._v("8")]),e("br"),e("span",{staticClass:"line-number"},[v._v("9")]),e("br"),e("span",{staticClass:"line-number"},[v._v("10")]),e("br"),e("span",{staticClass:"line-number"},[v._v("11")]),e("br"),e("span",{staticClass:"line-number"},[v._v("12")]),e("br")])]),e("h3",{attrs:{id:"数据流向"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据流向"}},[v._v("#")]),v._v(" 数据流向")]),v._v(" "),e("p",[e("img",{attrs:{src:"/images/git-compose.png",alt:"git-compose"}})]),v._v(" "),e("ol",[e("li",[v._v("在工作目录中添加、修改文件")]),v._v(" "),e("li",[v._v("将需要进行版本管理的文件放入暂存区")]),v._v(" "),e("li",[v._v("将暂存区的文件提交到仓库区")])]),v._v(" "),e("p",[v._v("因此，git 中的文件有三种状态：")]),v._v(" "),e("ol",[e("li",[e("code",[v._v("modified")]),v._v(" - 已修改")]),v._v(" "),e("li",[e("code",[v._v("staged")]),v._v(" - 已暂存")]),v._v(" "),e("li",[e("code",[v._v("committed")]),v._v(" - 已提交")])]),v._v(" "),e("h3",{attrs:{id:"数据结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[v._v("#")]),v._v(" 数据结构")]),v._v(" "),e("p",[e("code",[v._v("git")]),v._v(" 的核心是它的对象数据库，保存着 "),e("code",[v._v("git")]),v._v(" 的对象，其中最重要的是 "),e("code",[v._v("blob")]),v._v(" 对象、"),e("code",[v._v("tree")]),v._v("对象和 "),e("code",[v._v("commit")]),v._v(" 对象")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("blob 对象")]),v._v("：存储文件的内容（表示一个不可变、原始数据的类文件对象），实现了对文件内容的记录")]),v._v(" "),e("li",[e("code",[v._v("tree 对象")]),v._v("：存储一个目录结构，以及子文件或子文件夹的权限、类型、对应的身份证（"),e("code",[v._v("SHA-1")]),v._v(" 值）、文件名，实现了对文件夹的记录")]),v._v(" "),e("li",[e("code",[v._v("commit 对象")]),v._v("：存储一个提交信息，包括对应目录结构的快照 "),e("code",[v._v("tree 对象")]),v._v(" 的哈希值、上一个提交的哈希值、提交的作者、提交的时间以及提交的具体信息，实现了对提交信息的记录")])]),v._v(" "),e("p",[e("img",{attrs:{src:"/images/git-structure.png",alt:"git-structure"}})]),v._v(" "),e("p",[v._v("这三类对象，完美实现了 "),e("code",[v._v("git")]),v._v(" 的基础功能 "),e("strong",[v._v("对版本状态的记录")])]),v._v(" "),e("p",[v._v("运行 "),e("code",[v._v("git add")]),v._v(" 和 "),e("code",[v._v("git commit")]),v._v(" 命令时， "),e("code",[v._v("git")]),v._v(" 所做的实质工作是将被改写的文件保存为数据对象，更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象，数据对象、树对象、提交对象，最初均以单独文件的形式保存在 "),e("code",[v._v(".git/objects/")]),v._v(" 目录下")]),v._v(" "),e("p",[e("code",[v._v("git")]),v._v(" 存储的是以文件的内容、目录结构、"),e("code",[v._v("commit")]),v._v(" 信息等信息作为值，以要存储的数据和一个头部信息作 "),e("code",[v._v("SHA-1")]),v._v(" 校验运算得到的校验和为 "),e("code",[v._v("key")]),v._v("，以 "),e("code",[v._v("key-value")]),v._v(" 键值对的形式存储的数据库结合默克尔树形成的有向无环图（"),e("code",[v._v("DAG")]),v._v("）")]),v._v(" "),e("p",[v._v("以上，"),e("code",[v._v("git")]),v._v(" 解决了版本状态记录的问题，在此基础上还实现了版本切换、差异比较、分支管理、分布式协作等炫酷功能")]),v._v(" "),e("p",[e("strong",[v._v("git 底层命令")])]),v._v(" "),e("ul",[e("li",[e("code",[v._v("git hash-object")]),v._v(": 用于向Git数据库中写入数据")]),v._v(" "),e("li",[e("code",[v._v("git cat-file")]),v._v(": 用于查看Git数据库中数据")]),v._v(" "),e("li",[e("code",[v._v("git update-index")]),v._v(": 用于创建暂存区")]),v._v(" "),e("li",[e("code",[v._v("git ls-files")]),v._v(": 用于查看暂存区内容")]),v._v(" "),e("li",[e("code",[v._v("git write-tree")]),v._v(": 用于将暂存区内容写入一个树对象")]),v._v(" "),e("li",[e("code",[v._v("git commit-tree")]),v._v(": 用于创建提交对象")]),v._v(" "),e("li",[e("code",[v._v("git update-ref")]),v._v(": 用于创建或修改引用文件")])]),v._v(" "),e("h2",{attrs:{id:"git-hooks"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-hooks"}},[v._v("#")]),v._v(" Git hooks")]),v._v(" "),e("p",[v._v("在重要动作发生时触发的脚本，可以由任何可执行脚本组成，如 "),e("code",[v._v("Shell、Ruby、Python")]),v._v(" 脚本，可以看成生命周期执行函数。（例如前端 "),e("code",[v._v("MVVM")]),v._v(" 框架的生命周期函数）")]),v._v(" "),e("p",[v._v("钩子分两种，客户端钩子 和 服务端钩子")]),v._v(" "),e("p",[e("strong",[v._v("客户端钩子")]),v._v("：由诸如提交和合并这样的操作所调用")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("pre-commit")]),v._v(": 在键入提交信息前运行。 它用于检查即将提交的快照，例如，检查是否有所遗漏，确保测试运行，以及核查代码")]),v._v(" "),e("li",[e("code",[v._v("prepare-commit-msg")]),v._v(": 在启动提交信息编辑器之前，默认信息被创建之后运行，它允许你编辑提交者所看到的默认信息")]),v._v(" "),e("li",[e("code",[v._v("commit-msg")]),v._v(": 接收一个参数，此参数即上文提到的，存有当前提交信息的临时文件的路径")]),v._v(" "),e("li",[e("code",[v._v("post-commit")]),v._v(": 在整个提交过程完成后运行")]),v._v(" "),e("li",[e("code",[v._v("pre-rebase")]),v._v(": 运行于变基之前，以非零值退出可以中止变基的过程")]),v._v(" "),e("li",[e("code",[v._v("post-rewrite")]),v._v(": 被那些会替换提交记录的命令调用，比如 "),e("code",[v._v("git commit --amend")]),v._v(" 和 "),e("code",[v._v("git rebase")])]),v._v(" "),e("li",[e("code",[v._v("post-checkout")]),v._v(": 在 "),e("code",[v._v("git checkout")]),v._v(" 成功运行后会被调用")]),v._v(" "),e("li",[e("code",[v._v("post-merge")]),v._v(": 在 "),e("code",[v._v("git merge")]),v._v(" 成功运行后会被调用")]),v._v(" "),e("li",[e("code",[v._v("pre-push")]),v._v(": 钩子会在 "),e("code",[v._v("git push")]),v._v(" 运行期间，更新了远程引用但尚未传送对象时被调用")])]),v._v(" "),e("p",[e("strong",[v._v("服务端钩子")]),v._v("：用于诸如接收被推送的提交这样的联网操作")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("pre-receive")]),v._v(": 处理来自客户端的推送操作时调用")]),v._v(" "),e("li",[e("code",[v._v("update")]),v._v(": update 脚本和 pre-receive 脚本十分类似，不同之处在于它会为每一个准备更新的分支各运行一次")]),v._v(" "),e("li",[e("code",[v._v("post-receive")]),v._v(": 在整个过程完结以后运行，可以用来更新其他系统服务或者通知用户")])]),v._v(" "),e("h2",{attrs:{id:"gerrit"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#gerrit"}},[v._v("#")]),v._v(" Gerrit")]),v._v(" "),e("p",[e("code",[v._v("Gerrit")]),v._v(" 是基于 "),e("code",[v._v("SSH")]),v._v(" 协议实现的一套 "),e("code",[v._v("Git")]),v._v(" 服务器，这样就可以对 Git 数据推送进行更为精确的控制，为强制审核的实现建立了基础。其默认端口是 "),e("code",[v._v("29418")])]),v._v(" "),e("p",[e("code",[v._v("Gerrit")]),v._v(" 的 Git 服务器禁止用户直接向 "),e("code",[v._v("refs/heads")]),v._v(" 命名空间下的引用执行推送（除非特别的授权），而是建立 "),e("code",[v._v("refs/for/<branch-name>")]),v._v(" 和 "),e("code",[v._v("refs/changes/nn/<task-id>/m")]),v._v(" 的特殊引用，向 "),e("code",[v._v("refs/for/<branch-name>")]),v._v(" 命名空间下推送并不会在其中创建引用，而是为新的提交分配一个 ID，称为 "),e("code",[v._v("task-id")]),v._v("，并为该 "),e("code",[v._v("task-id")]),v._v(" 的访问建立 "),e("code",[v._v("refs/changes/nn/<task-id>/m")]),v._v(" 格式的引用，其中：")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("task-id")]),v._v(" 为 Gerrit 为评审任务顺序分配的全局唯一的号码")]),v._v(" "),e("li",[e("code",[v._v("nn")]),v._v(" 为 task-id 的后两位数，位数不足用零补齐。即 nn 为 task-id 除以 100 的余数")]),v._v(" "),e("li",[e("code",[v._v("m")]),v._v(" 为修订号，该 task-id 的首次提交修订号为 1，如果该修订被打回，重新提交修订号会自增")])]),v._v(" "),e("p",[v._v("为了保证已提交审核的修订通过审核入库后，被别的分支 "),e("code",[v._v("cherry-pick")]),v._v(" 后再推送至服务器时不会产生新的重复的评审任务，Gerrit 设计了一套方法，即：")]),v._v(" "),e("ul",[e("li",[v._v("要求每个提交包含唯一的 "),e("code",[v._v("Change-Id")]),v._v("，Change-Id 包含在提交日志的 "),e("code",[v._v("footer")]),v._v(" 中，当执行 "),e("code",[v._v("cherry-pick")]),v._v(" 时也会保留")]),v._v(" "),e("li",[v._v("为了实现 Git 提交中包含唯一的 Change-Id，Gerrit 使用了 "),e("code",[v._v("hooks/commit-msg")]),v._v(" 钩子，钩子脚本在提交时自动在提交信息中添加 "),e("code",[v._v("Change-Id: I...")])]),v._v(" "),e("li",[v._v("当 Gerrit 获取到用户向 "),e("code",[v._v("refs/for/<branch-name>")]),v._v(" 推送的提交中包含 "),e("code",[v._v("Change-Id: I...")]),v._v(" 时，如果该 "),e("code",[v._v("Change-Id")]),v._v(" 之前没有见过，会创建一个新的评审任务并分配新的 "),e("code",[v._v("task-id")]),v._v("，并在 Gerrit 的数据库中保存 "),e("code",[v._v("Change-Id")]),v._v(" 和 "),e("code",[v._v("Task-Id")]),v._v(" 的关联，如果包含了已经处理过的 "),e("code",[v._v("Change-Id")]),v._v("，就不再创建新的评审任务和 "),e("code",[v._v("task-id")]),v._v("，而直接将提交入库")]),v._v(" "),e("li",[v._v("如果用户的提交需要修改，建议开发者保持提交信息中的 "),e("code",[v._v("Change-Id: I...")]),v._v(" 部分以避免创建新的评审任务，只需选择一个新的修订号")])]),v._v(" "),e("blockquote",[e("p",[e("a",{attrs:{href:"https://www.worldhello.net/2010/11/10/2059.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("Gerrit 代码审核服务器的工作流和原理"),e("OutboundLink")],1)])]),v._v(" "),e("h2",{attrs:{id:"git-flow"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-flow"}},[v._v("#")]),v._v(" Git Flow")]),v._v(" "),e("p",[v._v("一个好的开发模式，可以提高团队的开发效率，同时提高团队的代码质量")]),v._v(" "),e("p",[e("img",{attrs:{src:"/images/git-flow.png",alt:"git-flow"}})]),v._v(" "),e("p",[e("img",{attrs:{src:"/images/git-assist.png",alt:"git-assist"}})]),v._v(" "),e("h3",{attrs:{id:"长期分支"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#长期分支"}},[v._v("#")]),v._v(" 长期分支")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("master")]),v._v(" 仓库默认创建分支，可执行版本记录分支，上面的每个节点都是发布到线上的一个版本，具体的版本号【"),e("a",{attrs:{href:"https://semver.org/",target:"_blank",rel:"noopener noreferrer"}},[v._v("语义化版本 2.0.0"),e("OutboundLink")],1),v._v("】由 "),e("code",[v._v("tag")]),v._v(" 确定")]),v._v(" "),e("li",[e("code",[v._v("develop")]),v._v(" 代码开发分支，基于远程 "),e("code",[v._v("master")]),v._v(" 分支创建，保有当前即将发布或是已经发布的代码，是确定的下一次将要通过 "),e("code",[v._v("release")]),v._v(" 分支合并到 "),e("code",[v._v("master")]),v._v(" 上的分支")])]),v._v(" "),e("h3",{attrs:{id:"短期分支"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#短期分支"}},[v._v("#")]),v._v(" 短期分支")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("feature")]),v._v(" 详细功能分支，每个功能分支应该尽可能的小，开发完成之后尽快移入仓库中")]),v._v(" "),e("li",[e("code",[v._v("release")]),v._v(" 测试版本发布分支，同时接收该版本的 "),e("code",[v._v("bugfix")]),v._v("，直到稳定之后再发布到 "),e("code",[v._v("master")]),v._v("，同时并合并到 "),e("code",[v._v("develop")]),v._v(" 分支")]),v._v(" "),e("li",[e("code",[v._v("hotfix")]),v._v(" 紧急修复线上 "),e("code",[v._v("bug")]),v._v(" 分支，直接从 "),e("code",[v._v("master")]),v._v(" 的版本分出，同时最小版本号加 1，修复完成后发布一个最新版本，同时合并到 "),e("code",[v._v("develop")]),v._v(" 分支")])]),v._v(" "),e("blockquote",[e("p",[v._v("符合项目和团队的 "),e("code",[v._v("git")]),v._v(" 开发模式，才是真正意义上的 "),e("code",[v._v("git-flow")])])]),v._v(" "),e("h2",{attrs:{id:"实用技巧"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实用技巧"}},[v._v("#")]),v._v(" 实用技巧")]),v._v(" "),e("ul",[e("li",[v._v("你每一行命令，你都知道你在干什么，仓库的数据流向是什么")]),v._v(" "),e("li",[e("code",[v._v("git commit")]),v._v(" 之前先 "),e("code",[v._v("git status")]),v._v(" 检查一下有没有无意间改动了其他文件")]),v._v(" "),e("li",[e("code",[v._v("git commit --amend")]),v._v(" 修改最近一次 "),e("code",[v._v("commit")])]),v._v(" "),e("li",[v._v("写好 "),e("code",[v._v("commit message")]),v._v("，推荐规范 "),e("a",{attrs:{href:"https://www.conventionalcommits.org/zh-hans/v1.0.0-beta.4/",target:"_blank",rel:"noopener noreferrer"}},[v._v("Conventional Commits"),e("OutboundLink")],1)]),v._v(" "),e("li",[v._v("提交之后结合界面工具，进一步确认，等需要部署的时候再 "),e("code",[v._v("merge")]),v._v(" 代码")]),v._v(" "),e("li",[v._v("不要使用 "),e("code",[v._v("git push -f")]),v._v("，除非是个人项目或个人分支（自认倒霉吧）")]),v._v(" "),e("li",[v._v("对比两个分支不同文件的统计 "),e("code",[v._v("git diff --stat origin/<branch-name>")])]),v._v(" "),e("li",[v._v("对比两个分支的不同提交 "),e("code",[v._v("git log <branch-name>..origin/<branch-name>")])]),v._v(" "),e("li",[e("code",[v._v("git reset")]),v._v(" 撤销代码的各种情况")]),v._v(" "),e("li",[v._v("不要在公共的远程分支中使用 "),e("code",[v._v("rebase")]),v._v("、"),e("code",[v._v("reset")]),v._v("等会修改这条分支已经存在的 "),e("code",[v._v("commit object")]),v._v(" 的命令")]),v._v(" "),e("li",[e("code",[v._v("git rebase -i")]),v._v(" 交互式的妙用，可对提交记录进行修改")]),v._v(" "),e("li",[e("code",[v._v("git reflog")]),v._v("的妙用，"),e("code",[v._v("ref")]),v._v(" 的 "),e("code",[v._v("log")]),v._v("，也可以理解成"),e("strong",[v._v("版本控制的版本控制")])]),v._v(" "),e("li",[e("code",[v._v("git bisect")]),v._v(" 二分查找出现问题的变更节点")])]),v._v(" "),e("h2",{attrs:{id:"提效"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#提效"}},[v._v("#")]),v._v(" 提效")]),v._v(" "),e("ul",[e("li",[v._v("安装 "),e("code",[v._v("iTerm2 & zsh & oh-my-zsh")]),v._v("，"),e("a",{attrs:{href:"https://starship.rs/",target:"_blank",rel:"noopener noreferrer"}},[v._v("推荐主题 Starship"),e("OutboundLink")],1),v._v("，强大的命令提示和 "),e("code",[v._v("alias")])]),v._v(" "),e("li",[v._v("多使用 "),e("code",[v._v("Tab")]),v._v(" 键，快速提示的前提下，还能检测已输入的命令有没有错误")]),v._v(" "),e("li",[v._v("常用 "),e("code",[v._v("IDE")]),v._v(" 配置合理插件，命令行操作搭配 "),e("code",[v._v("IDE")]),v._v(" 解决冲突和代码校验更高效")]),v._v(" "),e("li",[v._v("推荐 "),e("code",[v._v("git")]),v._v(" 上手游戏 "),e("a",{attrs:{href:"https://github.com/pcottle/learnGitBranching",target:"_blank",rel:"noopener noreferrer"}},[v._v("learnGitBranching"),e("OutboundLink")],1)])]),v._v(" "),e("comment")],1)}),[],!1,null,null,null);_.default=i.exports}}]);